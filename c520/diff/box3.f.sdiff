      SUBROUTINE BOX3						      SUBROUTINE BOX3
 								 
C------------------------------------------------------------	C------------------------------------------------------------
C								C
C  CHECKS PASSAGE THROUGH OBSERVATION LEVEL(S)			C  CHECKS PASSAGE THROUGH OBSERVATION LEVEL(S)
C  IRET1=1 KILLS PARTICLE					C  IRET1=1 KILLS PARTICLE
C  IRET2=1 PARTICLE HAS BEEN CUTTED IN UPDATE			C  IRET2=1 PARTICLE HAS BEEN CUTTED IN UPDATE
C  THIS SUBROUTINE IS CALLED FROM MAIN				C  THIS SUBROUTINE IS CALLED FROM MAIN
C------------------------------------------------------------	C------------------------------------------------------------
 								 
      IMPLICIT NONE						      IMPLICIT NONE
*KEEP,GENER.							*KEEP,GENER.
      COMMON /GENER/   GEN,ALEVEL				      COMMON /GENER/   GEN,ALEVEL
      DOUBLE PRECISION GEN,ALEVEL				      DOUBLE PRECISION GEN,ALEVEL
*KEEP,IRET.							*KEEP,IRET.
      COMMON /IRET/    IRET1,IRET2				      COMMON /IRET/    IRET1,IRET2
      INTEGER          IRET1,IRET2				      INTEGER          IRET1,IRET2
*KEEP,LONGI.							*KEEP,LONGI.
      COMMON /LONGI/   APLONG,HLONG,PLONG,SPLONG,THSTEP,THSTP	      COMMON /LONGI/   APLONG,HLONG,PLONG,SPLONG,THSTEP,THSTP
     *                 NSTEP,LLONGI,FLGFIT			     *                 NSTEP,LLONGI,FLGFIT
      DOUBLE PRECISION APLONG(0:1040,9),HLONG(0:1024),PLONG(0	      DOUBLE PRECISION APLONG(0:1040,9),HLONG(0:1024),PLONG(0
     *                 SPLONG(0:1040,9),THSTEP,THSTPI		     *                 SPLONG(0:1040,9),THSTEP,THSTPI
      INTEGER          NSTEP					      INTEGER          NSTEP
      LOGICAL          LLONGI,FLGFIT				      LOGICAL          LLONGI,FLGFIT
*KEEP,OBSPAR.							*KEEP,OBSPAR.
      COMMON /OBSPAR/  OBSLEV,THCKOB,XOFF,YOFF,THETAP,PHIP,	      COMMON /OBSPAR/  OBSLEV,THCKOB,XOFF,YOFF,THETAP,PHIP,
     *                 THETPR,PHIPR,NOBSLV			     *                 THETPR,PHIPR,NOBSLV
      DOUBLE PRECISION OBSLEV(10),THCKOB(10),XOFF(10),YOFF(10	      DOUBLE PRECISION OBSLEV(10),THCKOB(10),XOFF(10),YOFF(10
     *                 THETAP,THETPR(2),PHIP,PHIPR(2)		     *                 THETAP,THETPR(2),PHIP,PHIPR(2)
      INTEGER          NOBSLV					      INTEGER          NOBSLV
*KEEP,PAM.							*KEEP,PAM.
      COMMON /PAM/     PAMA,SIGNUM				      COMMON /PAM/     PAMA,SIGNUM
      DOUBLE PRECISION PAMA(6000),SIGNUM(6000)			      DOUBLE PRECISION PAMA(6000),SIGNUM(6000)
*KEEP,PARPAR.							*KEEP,PARPAR.
      COMMON /PARPAR/  CURPAR,SECPAR,PRMPAR,OUTPAR,C,		      COMMON /PARPAR/  CURPAR,SECPAR,PRMPAR,OUTPAR,C,
     *                 E00,E00PN,PTOT0,PTOT0N,THICKH,ITYPE,LE	     *                 E00,E00PN,PTOT0,PTOT0N,THICKH,ITYPE,LE
      DOUBLE PRECISION CURPAR(14),SECPAR(14),PRMPAR(14),OUTPA	      DOUBLE PRECISION CURPAR(14),SECPAR(14),PRMPAR(14),OUTPA
     *                 C(50),E00,E00PN,PTOT0,PTOT0N,THICKH	     *                 C(50),E00,E00PN,PTOT0,PTOT0N,THICKH
      INTEGER          ITYPE,LEVL				      INTEGER          ITYPE,LEVL
*KEEP,PARPAE.							*KEEP,PARPAE.
      DOUBLE PRECISION GAMMA,COSTHE,PHI,H,T,X,Y,CHI,BETA,GCM,	      DOUBLE PRECISION GAMMA,COSTHE,PHI,H,T,X,Y,CHI,BETA,GCM,
      EQUIVALENCE      (CURPAR(2),GAMMA),  (CURPAR(3),COSTHE)	      EQUIVALENCE      (CURPAR(2),GAMMA),  (CURPAR(3),COSTHE)
     *                 (CURPAR(4), PHI ),  (CURPAR(5), H    )	     *                 (CURPAR(4), PHI ),  (CURPAR(5), H    )
     *                 (CURPAR(6), T   ),  (CURPAR(7), X    )	     *                 (CURPAR(6), T   ),  (CURPAR(7), X    )
     *                 (CURPAR(8), Y   ),  (CURPAR(9), CHI  )	     *                 (CURPAR(8), Y   ),  (CURPAR(9), CHI  )
     *                 (CURPAR(10),BETA),  (CURPAR(11),GCM  )	     *                 (CURPAR(10),BETA),  (CURPAR(11),GCM  )
     *                 (CURPAR(12),ECM )			     *                 (CURPAR(12),ECM )
*KEEP,RANDPA.							*KEEP,RANDPA.
      COMMON /RANDPA/  FAC,U1,U2,RD,NSEQ,ISEED,KNOR		      COMMON /RANDPA/  FAC,U1,U2,RD,NSEQ,ISEED,KNOR
      DOUBLE PRECISION FAC,U1,U2				      DOUBLE PRECISION FAC,U1,U2
      REAL             RD(3000)					      REAL             RD(3000)
      INTEGER          ISEED(103,10),NSEQ			      INTEGER          ISEED(103,10),NSEQ
      LOGICAL          KNOR					      LOGICAL          KNOR
*KEEP,RUNPAR.							*KEEP,RUNPAR.
      COMMON /RUNPAR/  FIXHEI,THICK0,HILOECM,HILOELB,		      COMMON /RUNPAR/  FIXHEI,THICK0,HILOECM,HILOELB,
     *                 STEPFC,NRRUN,NSHOW,PATAPE,MONIIN,	     *                 STEPFC,NRRUN,NSHOW,PATAPE,MONIIN,
     *                 MONIOU,MDEBUG,NUCNUC,			     *                 MONIOU,MDEBUG,NUCNUC,
     *                 CETAPE,					     *                 CETAPE,
     *                 SHOWNO,ISHW,NOPART,NRECS,NBLKS,MAXPRT,	     *                 SHOWNO,ISHW,NOPART,NRECS,NBLKS,MAXPRT,
     *                 N1STTR,MDBASE,				     *                 N1STTR,MDBASE,
     *                 DEBDEL,DEBUG,FDECAY,FEGS,FIRSTI,FIXINC	     *                 DEBDEL,DEBUG,FDECAY,FEGS,FIRSTI,FIXINC
     *                 FIX1I,FMUADD,FNKG,FPRINT,FDBASE		     *                 FIX1I,FMUADD,FNKG,FPRINT,FDBASE
     *                ,GHEISH,GHESIG				     *                ,GHEISH,GHESIG
      COMMON /RUNPAC/  DSN,HOST,USER				      COMMON /RUNPAC/  DSN,HOST,USER
      DOUBLE PRECISION FIXHEI,THICK0,HILOECM,HILOELB		      DOUBLE PRECISION FIXHEI,THICK0,HILOECM,HILOELB
      REAL             STEPFC					      REAL             STEPFC
      INTEGER          NRRUN,NSHOW,PATAPE,MONIIN,MONIOU,MDEBU	      INTEGER          NRRUN,NSHOW,PATAPE,MONIIN,MONIOU,MDEBU
     *                 SHOWNO,ISHW,NOPART,NRECS,NBLKS,MAXPRT,	     *                 SHOWNO,ISHW,NOPART,NRECS,NBLKS,MAXPRT,
     *                 N1STTR,MDBASE				     *                 N1STTR,MDBASE
      INTEGER          CETAPE					      INTEGER          CETAPE
      CHARACTER*79     DSN					      CHARACTER*79     DSN
      CHARACTER*20     HOST,USER				      CHARACTER*20     HOST,USER
 								 
      LOGICAL          DEBDEL,DEBUG,FDECAY,FEGS,FIRSTI,FIXINC	      LOGICAL          DEBDEL,DEBUG,FDECAY,FEGS,FIRSTI,FIXINC
     *                 FIX1I,FMUADD,FNKG,FPRINT,FDBASE		     *                 FIX1I,FMUADD,FNKG,FPRINT,FDBASE
     *                ,GHEISH,GHESIG				     *                ,GHEISH,GHESIG
*KEND.								*KEND.
 								 
c>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>	c>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
c   Simulate more precisely muons Cherenkov light		c   Simulate more precisely muons Cherenkov light
c------------------------------------------------------------	c------------------------------------------------------------
      integer          k					      integer          k
      double precision chloop,savpar(8),oldchi,oldthk,oldh	      double precision chloop,savpar(8),oldchi,oldthk,oldh
c>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>	c>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

      DOUBLE PRECISION HEIGH,HNEW,PROPAR(8),THCKHN		      DOUBLE PRECISION HEIGH,HNEW,PROPAR(8),THCKHN
      INTEGER          I,IRET3,J,L,LPCT1,LPCT2			      INTEGER          I,IRET3,J,L,LPCT1,LPCT2
      EXTERNAL         HEIGH					      EXTERNAL         HEIGH
C------------------------------------------------------------	C------------------------------------------------------------
 								 
      IF ( DEBUG ) WRITE(MDEBUG,444) (CURPAR(I),I=1,9)		      IF ( DEBUG ) WRITE(MDEBUG,444) (CURPAR(I),I=1,9)
  444 FORMAT(' BOX3  : CURPAR=',1P,9E10.3)			  444 FORMAT(' BOX3  : CURPAR=',1P,9E10.3)
 								 
      IF     ( ITYPE .EQ. 7 ) THEN				      IF     ( ITYPE .EQ. 7 ) THEN
C  PI 0 DECAYS INTO 2 PHOTONS IN SUBROUTINE PI0DEC		C  PI 0 DECAYS INTO 2 PHOTONS IN SUBROUTINE PI0DEC
        CALL TSTINI						        CALL TSTINI
        CALL PI0DEC						        CALL PI0DEC
        CALL TSTEND						        CALL TSTEND
        IRET1 = 1						        IRET1 = 1
        RETURN							        RETURN
 								 
      ELSEIF ( ITYPE .EQ. 5  .OR.  ITYPE .EQ. 6 ) THEN		      ELSEIF ( ITYPE .EQ. 5  .OR.  ITYPE .EQ. 6 ) THEN
C  MUONS ARE TRACKED WITHIN ROUTINE MUTRAC			C  MUONS ARE TRACKED WITHIN ROUTINE MUTRAC
        CALL TSTINI						        CALL TSTINI
        CALL MUTRAC						        CALL MUTRAC
        CALL TSTEND						        CALL TSTEND
        IRET1 = 1						        IRET1 = 1
        RETURN							        RETURN
 								 
      ELSEIF ( ITYPE .LE. 3 ) THEN				      ELSEIF ( ITYPE .LE. 3 ) THEN
C  ELECTRONS OR PHOTONS ARE TREATED IN SUBROUTINE EM		C  ELECTRONS OR PHOTONS ARE TREATED IN SUBROUTINE EM
        CALL EM							        CALL EM
        IRET1 = 1						        IRET1 = 1
        RETURN							        RETURN
 								 
      ELSEIF (     ITYPE .EQ. 17  .OR.				      ELSEIF (     ITYPE .EQ. 17  .OR.
     *        (ITYPE .GE. 71  .AND.  ITYPE .LE. 74)) THEN	     *        (ITYPE .GE. 71  .AND.  ITYPE .LE. 74)) THEN
C  ETA DECAYS WITHIN ROUTINE ETADEC				C  ETA DECAYS WITHIN ROUTINE ETADEC
        CALL TSTINI						        CALL TSTINI
        CALL ETADEC						        CALL ETADEC
        CALL TSTEND						        CALL TSTEND
        IRET1 = 1						        IRET1 = 1
        RETURN							        RETURN
 								 
      ELSEIF ( ITYPE .GE. 51  .AND.  ITYPE .LE. 65 ) THEN	      ELSEIF ( ITYPE .GE. 51  .AND.  ITYPE .LE. 65 ) THEN
C  RESONANCES DECAY WITHIN ROUTINE RESDEC			C  RESONANCES DECAY WITHIN ROUTINE RESDEC
        CALL TSTINI						        CALL TSTINI
        CALL RESDEC						        CALL RESDEC
        CALL TSTEND						        CALL TSTEND
        IRET1 = 1						        IRET1 = 1
        RETURN							        RETURN
 								 
      ENDIF							      ENDIF
 								 
C  FOR ALL THE OTHER PARTICLES THE PLACE OF NEXT INTERACTION 	C  FOR ALL THE OTHER PARTICLES THE PLACE OF NEXT INTERACTION 
C  DETERMINED IN BOX2						C  DETERMINED IN BOX2
c>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>	c>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
c   This is just a first approach to the problem		c   This is just a first approach to the problem
c------------------------------------------------------------	c------------------------------------------------------------

c      goto 5991						c      goto 5991
      if ( itype .eq. 5 .or. itype .eq. 6 ) then		      if ( itype .eq. 5 .or. itype .eq. 6 ) then
        oldthk = thickh     					        oldthk = thickh     
        do 5101  i = 1,9					        do 5101  i = 1,9
          savpar(i) = curpar(i)					          savpar(i) = curpar(i)
 5101   continue						 5101   continue
        chi = 0.2d0 * chi					        chi = 0.2d0 * chi
        do 5100  k = 1,5					        do 5100  k = 1,5
c  calculate hight difference in cm from given chi in g/cm**2	c  calculate hight difference in cm from given chi in g/cm**2
          thckhn = thickh + costhe * chi			          thckhn = thickh + costhe * chi
          hnew   = heigh(thckhn)				          hnew   = heigh(thckhn)
c  update particle to interaction point (if it reaches so far	c  update particle to interaction point (if it reaches so far
c  and store coordinates in propar				c  and store coordinates in propar
          call update( hnew, thckhn, 0 )			          call update( hnew, thckhn, 0 )
          if ( iret2 .ne. 0 ) goto 5104				          if ( iret2 .ne. 0 ) goto 5104
          do 5103  i = 1,8					          do 5103  i = 1,8
            curpar(i) = outpar(i)				            curpar(i) = outpar(i)
 5103     continue						 5103     continue
          thickh = thckhn 					          thickh = thckhn 
 5100   continue						 5100   continue
 5104   continue						 5104   continue
        thickh = oldthk						        thickh = oldthk
        do 5102  i = 1,9					        do 5102  i = 1,9
          curpar(i) = savpar(i)					          curpar(i) = savpar(i)
 5102   continue						 5102   continue
        							        
      else							      else
c  calculate hight difference in cm from given chi in g/cm**2	c  calculate hight difference in cm from given chi in g/cm**2
        thckhn = thickh + costhe * chi				        thckhn = thickh + costhe * chi
        hnew   = heigh(thckhn)					        hnew   = heigh(thckhn)
c  update particle to interaction point (if it reaches so far	c  update particle to interaction point (if it reaches so far
c  and store coordinates in propar				c  and store coordinates in propar
        call update( hnew, thckhn, 0 )				        call update( hnew, thckhn, 0 )
          							          
      endif							      endif
        							        
      goto 5992							      goto 5992
c>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>	c>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
c 5991 continue							c 5991 continue
c								c
cC     CALCULATE HIGHT DIFFERENCE IN CM FROM GIVEN CHI IN G/C	cC     CALCULATE HIGHT DIFFERENCE IN CM FROM GIVEN CHI IN G/C
c      THCKHN = THICKH + COSTHE * CHI				c      THCKHN = THICKH + COSTHE * CHI
c      HNEW   = HEIGH(THCKHN)					c      HNEW   = HEIGH(THCKHN)
cC     UPDATE PARTICLE TO INTERACTION POINT (IF IT REACHES SO	cC     UPDATE PARTICLE TO INTERACTION POINT (IF IT REACHES SO
cC     AND STORE COORDINATES IN PROPAR				cC     AND STORE COORDINATES IN PROPAR
c      CALL UPDATE( HNEW, THCKHN, 0 )				c      CALL UPDATE( HNEW, THCKHN, 0 )
c>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>	c>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

 5992 continue							 5992 continue
c>>> it was : >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>	c>>> it was : >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
cC  CALCULATE HIGHT DIFFERENCE IN CM FROM GIVEN CHI IN G/CM**	cC  CALCULATE HIGHT DIFFERENCE IN CM FROM GIVEN CHI IN G/CM**
c      THCKHN = THICKH + COSTHE * CHI				c      THCKHN = THICKH + COSTHE * CHI
c      HNEW   = HEIGH(THCKHN)					c      HNEW   = HEIGH(THCKHN)
c      IF (DEBUG) WRITE(MDEBUG,*)'BOX3  : THICKH,THCKHN,HNEW=	c      IF (DEBUG) WRITE(MDEBUG,*)'BOX3  : THICKH,THCKHN,HNEW=
c     *                    SNGL(THICKH),SNGL(THCKHN),SNGL(HNE	c     *                    SNGL(THICKH),SNGL(THCKHN),SNGL(HNE
cC  UPDATE PARTICLE TO INTERACTION POINT (IF IT REACHES SO FA	cC  UPDATE PARTICLE TO INTERACTION POINT (IF IT REACHES SO FA
cC  AND STORE COORDINATES IN PROPAR				cC  AND STORE COORDINATES IN PROPAR
c      CALL UPDATE( HNEW, THCKHN, 0 )				c      CALL UPDATE( HNEW, THCKHN, 0 )
c>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>	c>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

      IF ( DEBUG ) THEN						      IF ( DEBUG ) THEN
        WRITE(MDEBUG,455) IRET1,IRET2				        WRITE(MDEBUG,455) IRET1,IRET2
  455   FORMAT(' BOX3  : IRET1..2=',2I5)			  455   FORMAT(' BOX3  : IRET1..2=',2I5)
        IF ( IRET2 .EQ. 0 ) WRITE(MDEBUG,454) (OUTPAR(I),I=1,	        IF ( IRET2 .EQ. 0 ) WRITE(MDEBUG,454) (OUTPAR(I),I=1,
  454   FORMAT(' BOX3  : OUTPAR=',1P,8E10.3)			  454   FORMAT(' BOX3  : OUTPAR=',1P,8E10.3)
      ENDIF							      ENDIF
C  STORE PARTICLE FOR FURTHER TREATMENT				C  STORE PARTICLE FOR FURTHER TREATMENT
      IF ( IRET2 .EQ. 0 ) THEN					      IF ( IRET2 .EQ. 0 ) THEN
        DO  3  I = 1,8						        DO  3  I = 1,8
          PROPAR(I) = OUTPAR(I)					          PROPAR(I) = OUTPAR(I)
   3    CONTINUE						   3    CONTINUE
        IRET3 = 0						        IRET3 = 0
      ELSE							      ELSE
C  PARTICLE CUTTED AT INTERACTION POINT; IT MAY HOWEVER PASS 	C  PARTICLE CUTTED AT INTERACTION POINT; IT MAY HOWEVER PASS 
C  OBSERVATION LEVELS						C  OBSERVATION LEVELS
        IRET3 = 1						        IRET3 = 1
      ENDIF							      ENDIF
 								 
C  HERE THE ENDPOINT OF THE CURRENT TRACKING STEP IS WELL DEF	C  HERE THE ENDPOINT OF THE CURRENT TRACKING STEP IS WELL DEF
C  THE PARTICLE IS TRACKED FROM THICKH DOWN TO THCKHN		C  THE PARTICLE IS TRACKED FROM THICKH DOWN TO THCKHN
C  COUNT THE PARTICLES FOR THE LONGITUDINAL DEVELOPMENT		C  COUNT THE PARTICLES FOR THE LONGITUDINAL DEVELOPMENT
      IF ( LLONGI ) THEN					      IF ( LLONGI ) THEN
        LPCT1 = INT(THICKH*THSTPI + 1.D0)			        LPCT1 = INT(THICKH*THSTPI + 1.D0)
        LPCT2 = INT(THCKHN*THSTPI)				        LPCT2 = INT(THCKHN*THSTPI)
        LPCT2 = MIN(NSTEP,LPCT2)				        LPCT2 = MIN(NSTEP,LPCT2)
C  ALL HADRONS							C  ALL HADRONS
        IF     ( ITYPE .GE. 7 .AND. ITYPE .LE. 41 ) THEN	        IF     ( ITYPE .GE. 7 .AND. ITYPE .LE. 41 ) THEN
          DO 5004 L = LPCT1,LPCT2				          DO 5004 L = LPCT1,LPCT2
            PLONG(L,6) = PLONG(L,6) + 1.D0			            PLONG(L,6) = PLONG(L,6) + 1.D0
 5004     CONTINUE						 5004     CONTINUE
C  CHARGED HADRONS						C  CHARGED HADRONS
          IF ( SIGNUM(ITYPE) .NE. 0.D0 ) THEN			          IF ( SIGNUM(ITYPE) .NE. 0.D0 ) THEN
            DO 5005 L = LPCT1,LPCT2				            DO 5005 L = LPCT1,LPCT2
              PLONG(L,7) = PLONG(L,7) + 1.D0			              PLONG(L,7) = PLONG(L,7) + 1.D0
 5005       CONTINUE						 5005       CONTINUE
          ENDIF							          ENDIF
C  NUCLEI							C  NUCLEI
        ELSEIF ( ITYPE .GT. 100 ) THEN				        ELSEIF ( ITYPE .GT. 100 ) THEN
          DO 5006 L = LPCT1,LPCT2				          DO 5006 L = LPCT1,LPCT2
            PLONG(L,8) = PLONG(L,8) + 1.D0			            PLONG(L,8) = PLONG(L,8) + 1.D0
 5006     CONTINUE						 5006     CONTINUE
        ENDIF							        ENDIF
      ENDIF							      ENDIF
 								 
C  CHECK OBSERVATION LEVEL PASSAGE AND UPDATE PARTICLE COORDI	C  CHECK OBSERVATION LEVEL PASSAGE AND UPDATE PARTICLE COORDI
      DO  1  J = 1,NOBSLV					      DO  1  J = 1,NOBSLV
        IF ( HNEW .GT. OBSLEV(J) ) GOTO 2			        IF ( HNEW .GT. OBSLEV(J) ) GOTO 2
        IF ( H    .LT. OBSLEV(J) ) GOTO 1			        IF ( H    .LT. OBSLEV(J) ) GOTO 1
C  REMEMBER NUMBER OF LEVEL FOR OUTPUT				C  REMEMBER NUMBER OF LEVEL FOR OUTPUT
        LEVL  = J						        LEVL  = J
        CALL UPDATE( OBSLEV(J), THCKOB(J), J )			        CALL UPDATE( OBSLEV(J), THCKOB(J), J )
        IF (DEBUG) WRITE(MDEBUG,456) J,IRET1,IRET2		        IF (DEBUG) WRITE(MDEBUG,456) J,IRET1,IRET2
  456   FORMAT(' BOX3  : LEVEL ',I5,' IRET1,2=',2I5)		  456   FORMAT(' BOX3  : LEVEL ',I5,' IRET1,2=',2I5)
 								 
C  IF PARTICLE IS NOT CUTTED, BRING IT TO OUTPUT		C  IF PARTICLE IS NOT CUTTED, BRING IT TO OUTPUT
        IF ( IRET2 .EQ. 0 ) THEN				        IF ( IRET2 .EQ. 0 ) THEN
          CALL OUTPUT						          CALL OUTPUT
        ENDIF							        ENDIF
   1  CONTINUE							   1  CONTINUE
 								 
C  KILL PARTICLE AS IT DECAYS OR INTERACTS BELOW LOWEST OBSLE	C  KILL PARTICLE AS IT DECAYS OR INTERACTS BELOW LOWEST OBSLE
      IRET1 = 1							      IRET1 = 1
      RETURN							      RETURN
 								 
C  PARTICLE INTERACTS OR DECAYS BEFORE PASSING OBSLEVEL		C  PARTICLE INTERACTS OR DECAYS BEFORE PASSING OBSLEVEL
   2  CONTINUE							   2  CONTINUE
 								 
C  PARTICLE IS NOW UPDATED TO POINT OF INTERACTION		C  PARTICLE IS NOW UPDATED TO POINT OF INTERACTION
      IF ( IRET3 .EQ. 0 ) THEN					      IF ( IRET3 .EQ. 0 ) THEN
        DO  5  J = 1,8						        DO  5  J = 1,8
          CURPAR(J) = PROPAR(J)					          CURPAR(J) = PROPAR(J)
   5    CONTINUE						   5    CONTINUE
        ALEVEL = H						        ALEVEL = H
        BETA   = SQRT( GAMMA**2 - 1.D0 ) / GAMMA		        BETA   = SQRT( GAMMA**2 - 1.D0 ) / GAMMA
      ELSE							      ELSE
C  ELIMINATE PARTICLE IF BELOW CUTS				C  ELIMINATE PARTICLE IF BELOW CUTS
        IRET1 = 1						        IRET1 = 1
      ENDIF							      ENDIF
 								 
      RETURN							      RETURN
      END							      END
