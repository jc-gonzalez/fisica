//!/////////////////////////////////////////////////////////////////////
//
// camera
//
// @file      camera.cxx
// @title     Camera simulation
// @subtitle  Code for the simulation of the camera phase
// @desc      Code for the simulation of the camera of CT1 and MAGIC
// @author    J C Gonzalez
// @date      Time-stamp: "Sat Feb 12 12:58:12 CET 2000"
// @email     gonzalez@mppmu.mpg.de
//
//----------------------------------------------------------------------
//
// Created:   Thu May  7 16:24:22 1998
// Author:    Jose Carlos Gonzalez
// Purpose:   Program for reflector simulation
// Notes:     See files README for details
//
//----------------------------------------------------------------------
//
// $RCSfile$
// $Revision$
// $Author$
// $Date$
//
////////////////////////////////////////////////////////////////////////
// @tableofcontents @coverpage

//=-----------------------------------------------------------
//# Source code of |camera.cxx|.

/*"
  In this section we show the (commented) code of the program for the
  read-out of the output files generated by the simulator of the
  reflector, |reflector 0.3|.
**/

//=-----------------------------------------------------------
//## Includes and file-scope variables definition.

/*"
  All the defines are located in the file |camera.h|.
**/

//{
#include "camera.h"
//}


//=-----------------------------------------------------------
//## Definition of global variables.

//{

/*"
  Now we define some global variables with data about the telescope,
  such as "focal distance",  number of pixels/mirrors,
  "size of the camera", and so on.
**/

/*"
  Depending on the telescope we are using (CT1 or MAGIC), the
  information stored in the definition file is different.
  The variable |ct_Type| has the value 0 when we use
  CT1, and 1 when we use MAGIC.
**/

//@: Type of telescope: 0:CT1, 1:MAGIC
static int   ct_Type;       

/*"
  And this is the information about the whole telescope.
**/

// parameters of the CT (from the CT definition file)

//@: Focal distances [cm]
static float *ct_Focal;

//@: Mean Focal distances [cm]
static float ct_Focal_mean;

//@: STDev. Focal distances [cm]
static float ct_Focal_std;

//@: Mean Point Spread function [cm]
static float ct_PSpread_mean;

//@: STDev. Point Spread function [cm]
static float ct_PSpread_std;

//@: STDev. Adjustmente deviation [cm]
static float ct_Adjustment_std;

//@: Radius of the Black Spot in mirror [cm]
static float ct_BlackSpot_rad;

//@: Radius of one mirror [cm]
static float ct_RMirror;

//@: Camera width [cm]
static float ct_CameraWidth;

//@: Half of Camera width [cm]
static float ct_CameraWidth_2;

//@: Pixel width [cm]
static float ct_PixelWidth;

//@: ct_PixelWidth_corner_2_corner = ct_PixelWidth / cos(60)
static float ct_PixelWidth_corner_2_corner;

//@: ct_PixelWidth_corner_2_corner / 2
static float ct_PixelWidth_corner_2_corner_half;

//@: Number of mirrors
static int ct_NMirrors = 0;

//@: Number of rings of small pixels
static int ct_NRings_small;

//@: Number of rings of big pixels
static int ct_NRings_big;

//@: Number of small pixels
static int ct_NPixels_small;

//@: Number of gap pixels
static int ct_NPixels_gap;

//@: Number of big pixels
static int ct_NPixels_big;

//@: Number (total) of pixels
static int ct_NPixels;

//@: Number of big pixels in the first sector of first ring
static int ct_NBig1;

//@: ct_Apot = ct_PixelWidth / 2
static float ct_Apot;

//@: ct_2Apot = 2 * ct_Apot = ct_PixelWidth
static float ct_2Apot;

//@: name of the CT definition file to use
static char ct_filename[256];

/*"
  The following double-pointer is a 2-dimensional table with information
  about each pixel. The routine |read_pixels()| will read
  this information from the file |pixels.dat|.
**/

// Pointer to a tables/Arrays with information about the pixels
// and data stored on them with information about the pixels

//@: table for IJ(K) system
static int pixels[PIX_ARRAY_SIDE][PIX_ARRAY_SIDE];

//@: coordinates x,y for each pixel
static float **pixary;

//@: indexes of pixels neighbours of a given one
static int **pixneig;

//@: number of neighbours a pixel have
static int *npixneig;

//@: contents of the pixels (ph.e.)
static float **fnpix;

//@: contents of the pixels (ph.e.) after cleanning
static float *fnpixclean;

/*"
  The following double-pointer is a 2-dimensional table with the
  Quantum Efficiency @$QE@$ of each pixel in the camera, as a function
  of the wavelength @$\lambda@$. The routine |read_pixels()| will read
  also this information from the file |qe.dat|.
**/

// Pointer to a table with QE, number of datapoints, and wavelengths

//@: table of QE
static float ***QE;

//@: number of datapoints for the QE curve
static int pointsQE;

//@: table of QE
static float *QElambda;

/*"
  The following is a table of HARD-CODED efficiencies. This should be
  changed some how...
**/

//" HARD-CODED efficiencies

//@: Efficiency of transmision for the Plexiglas
static const float Eff_Plexiglas = 0.95;

//@: Efficiency of transmision for the Plexiglas
static const float Eff_LightGuides = 0.90;

//@: Efficiency of transmision for the Plexiglas
static const float Eff_1stDynode = 0.90;

//@: Efficiency of transmision for the Plexiglas
static const float overall_Efficiency = ( Eff_Plexiglas *
                                          Eff_LightGuides *
                                          Eff_1stDynode );
/*"
  The following double-pointer is a 2-dimensional table with information
  about each mirror in the dish. The routine |read_ct_file()| will read
  this information from the CT definition file.
**/

// Pointer to a table with the following info.:

static float **ct_data;

/*
 *  TYPE=0  (CT1)
 *  i   s rho   theta   x   y   z   thetan  phin  xn   yn   zn
 *
 *     i : number of the mirror
 *     s : arc length [cm]
 *   rho : polar rho of the position of the center of the mirror [cm]
 * theta : polar angle of the position of the center of the mirror [cm]
 *     x : x coordinate of the center of the mirror [cm]
 *     y : y coordinate of the center of the mirror [cm]
 *     z : z coordinate of the center of the mirror [cm]
 *thetan : polar theta angle of the direction where the mirror points to
 *  phin : polar phi angle of the direction where the mirror points to
 *    xn : xn coordinate of the normal vector in the center (normalized)
 *    yn : yn coordinate of the normal vector in the center (normalized)
 *    zn : zn coordinate of the normal vector in the center (normalized)
 *
 *  TYPE=1  (MAGIC)
 *  i  f   sx   sy   x   y   z   thetan  phin
 *
 *      i : number of the mirror
 *      f : focal distance of that mirror
 *     sx : curvilinear coordinate of mirror's center in X[cm]
 *     sy : curvilinear coordinate of mirror's center in X[cm]
 *      x : x coordinate of the center of the mirror [cm]
 *      y : y coordinate of the center of the mirror [cm]
 *      z : z coordinate of the center of the mirror [cm]
 * thetan : polar theta angle of the direction where the mirror points to
 *   phin : polar phi angle of the direction where the mirror points to
 *     xn : xn coordinate of the normal vector in the center (normalized)
 *     yn : yn coordinate of the normal vector in the center (normalized)
 *     zn : zn coordinate of the normal vector in the center (normalized)
 */

/*"
  We define a table into where random numbers will be stored.
  The routines used for random number generation are provided by
  |RANLIB| (taken from NETLIB, |www.netlib.org|), and by
  the routine |double drand48(void)| (prototype defined in
  |stdlib.h|) through the macro |RandomNumber| defined in
  |camera.h|.
**/

//@: Table of random numbers
static double RandomNumbers[500];

/*"
  Trigger variables to be used.
**/

//@: Trigger pattern ID to use in the run
static TriggerPattern_type trigger_pattern_id;

//@: Number of trigger patterns valid for that Trigger pattern ID
static int trigger_npatterns;

//@: Trigger patterns valid for that Trigger pattern ID
static int *trigger_patterns;

/*"
  The following is a variable to count the number of Cphotons
  in the different steps of the simulation.
  The definition is as follows:
  @[
  \mbox{CountCphotons}[ \mbox{FILTER} ] \equiv
  \mbox{\it Number of photons after the filter} \mbox{FILTER}
  @]
  The filters are defined and can be found in the file |camera.h|.
**/

//@: vector to count photons at any given step of the simulation
static int CountCphotons[10];

/*"
  The following are the set of parameters calculated for each image.
  The routines for their calculations are in |moments.cxx|.
**/

// parameters of the images
static float xmax, ymax, *maxs;
static int *nmaxs;
static float length, width, dist, xdist, azw, miss, alpha, *conc;
static float phiasym, asymx, asymy;
static float charge, smax;

//@: structure with info. about the image
static Moments_Info *moments_ptr;

//@: structure with info. about islands
static Islands_Info *islands_ptr;

//@: structure with info. about lenwid
static LenWid_Info  *lenwid_ptr;

//}

//=-----------------------------------------------------------
//## Main program.

//{

//++++++++++++++++++++++++++++++++++++++++
// MAIN PROGRAM
//----------------------------------------

int
main(int argc, char **argv)
{

  //### Definition of variables.

  ifstream inputfile;         //@< stream for the input file
  ofstream outputfile;        //@< stream for the output file
  ofstream datafile;          //@< stream for the data file

  MCEventHeader mcevth;       //@< Event Header class (MC)
  MCCphoton     cphoton;      //@< Cherenkov Photon class (MC)

  char  pathname[256];        //@< source directory for input files
  char  cername[256];         //@< source cerXXXXXX file name
  char  staname[256];         //@< source datXXXXXX file name
  char  inname[256];          //@< input file name
  char  outname[256];         //@< output file name
  char  datname[256];         //@< data (ASCII) output file name
  char  hboname[256];         //@< HBOOK file name
  char  hbonamelnk[256];      //@< link to HBOOK file name
  char  hbookname[256];       //@< HBOOK file name
  char  parname[256];         //@< parameters file name
                           
  char  dummy[256];           //@< dummy char. variable
  char  sign[20];             //@< initialize sign
  char  flag[40];             //@< flags in the .rfl file

  float thetaCT, phiCT, xiCT; //@< parameters of a given shower
  float thetashw, phishw;     //@< parameters of a given shower
  float coreD, coreX, coreY;  //@< core position and distance
  float impactD;              //@< impact parameter
  float u, v, w;              //@< auxiliary variables
  float l1, m1, n1;           //@< auxiliary variables
  float l2, m2, n2;           //@< auxiliary variables
  float num, den;             //@< auxiliary variables

  int   nshow=0;              //@< partial number of shower in a given run
  int   ntshow=0;             //@< total number of showers
  int   ncph=0;               //@< partial number of shower in a given run
  int   ntcph=0;              //@< total number of showers
                              
  int   i, j, k, n, m;        //@< simple counters
  float x, y;                 //@< intermediate variables

  float t0, t1;               //@< initial and final times for the Cphotons
  float trange;               //@< time interval between first and last photon
  float t;                    //@< time for a single photon
  float phi;                  //@< phi angle of photon in the camera plane
  float cx, cy;               //@< coordinates in the XY system of the camera
  int   ki, kj, kk;           //@< coordinates of a pixel in the X'Y'Z' system

  int   nPMT;                 //@< number of pixel

  float wl, last_wl;          //@< wavelength of the photon
  float qe;                   //@< quantum efficiency
  float **qeptr = 0;          //@< quantum efficiency table

  int   whatIs;               //@< flag to identify datablocks in input file

  float muph, nph;            //@< mean and final value for the number of Cphs

  float nNSB;                 //@< final value for the NSB
      
  int   *Skip=0;              //@< list of showers to be skipped
  int   nSkip=0;              //@< number of showers to be skipped

  int   Data_From_STDIN = FALSE;  //@< flag: TRUE: data come from STDIN

  int   Read_Phe = FALSE;         //@< flag: TRUE: we are reading a PHE file
  int   Read_Phe_All = FALSE;     //@< flag: TRUE: read all data to file

  int   Write_All_Images = FALSE; //@< flag: TRUE: write all images to output
  int   Write_All_Data = FALSE;   //@< flag: TRUE: write all data to output

  int   Select_Energy = TRUE;        //@< flag: TRUE: selection on the energy
  float Select_Energy_le = 0.0;      //@< Lower edge energy range (in GeV)
  float Select_Energy_ue = 100000.0; //@< Upper edge of energy range (GeV)

  int   iTime_nbins;          //@< Number of bins in time histograms
  float fTime_mintime;        //@< Min. time in time time histograms
  float fTime_maxtime;        //@< Max. time in time time histograms

  int   iTime_pnbins;         //@< Number of bins in pixel time histograms
  float fTime_pmintime;       //@< Min. time in time pixel time histograms
  float fTime_pmaxtime;       //@< Max. time in time pixel time histograms

  int   iTime_discnbins;      //@< Number of bins in pixel discrim. histograms
  float fTime_discmintime;    //@< Min. time in time pixel discrim. histograms
  float fTime_discmaxtime;    //@< Max. time in time pixel discrim. histograms

  int   iTime_triggerbins;    //@< number of time bins for logic discrim. gate
                              
  int   nBefIntegBin;         //@< number of bins in integration before trigger
  int   nAftIntegBin;         //@< number of bins in integration after trigger
                              
  int   nMinIntegBin;         //@< first bin to use in integration
  int   nMaxIntegBin;         //@< last bin to use in integration
                              
  int   simulateNSB;          //@< will we simulate NSB?
  float meanNSB;              //@< NSB mean value (per pixel and ns)
  float meanNSBperbin;        //@< NSB mean value (per pixel and time bin)
  int   onlyNSB;              //@< simulate only NSB events
  int   eventsNSB;            //@< number of NSB events to simulate
  int   current_eventNSB;     //@< number of current NSB event
    
  float qThreshold;           //@< Threshold value
  float qTailCut;             //@< Tail Cut value
  int   nIslandsCut;          //@< Islands Cut value
  int   countIslands;         //@< will we count the islands?

  int   anaPixels;            //@< number of pixels in analysis (NOT WORKING!)

  float fCorrection;          //@< Factor to apply to pixel values (def. 1.)

  float q0;                   //@< trigger threshold ( intermediate variable )
  float maxcharge;            //@< maximum charge in pixels
  int   noverq0, novq0;       //@< number of pixels above threshold
  int   ngrpq0, mxgrp;        //@< number of pixels in a group
                              
  int   trigger;              //@< trigger flag
  int   itrigger;             //@< index of pixel fired
  int   ntrigger = 0;         //@< number of triggers in the whole file
  int   triggerBits;          //@< byte for trigger condition check (MAGIC)
  int   bit;                  //@< intermediate variable

  float plateScale_cm2deg;    //@< plate scale (deg/cm)
  float degTriggerZone;       //@< trigger area in the camera (radius, in deg.)

  float dtheta, dphi;         //@< deviations of CT from shower axis

  int   still_in_loop = FALSE;    //@< boolean variable for flow control
  int   exit_from_switch = FALSE; //@< boolean variable for flow control

  int   nvar;                 //@< number of parameters saved for each image
  float * image_data;         //@< vector with data from the image

  char  htimename[200];       //@< name of the time histogram file
  char  Signature[20];        //@< signature of the camera program
  int   hidt=2;               //@< extended shower number
  int   nbins;                //@< number of bins of the timing histos.
  float binmin, binmax;       //@< limits for the timing histos.
  int   ntimebin;             //@< time bin where the trigger is found

  float * spsX=0;             //@< vector of X data from the Single Phe. Spec.
  float * spsY=0;             //@< vector of Y data from the Single Phe. Spec.
  float sps_Mean;             //@< mean of the Single Phe. Spec.
  float sps_FWHM;             //@< FWHM of a single ph.e signal
  float sps_Sigma;            //@< Sigma of a single ph.e signal

  float nsb_added;            //@< NSB content added per time bin per pixel

  float tmpdeviation;         //@< temporary variable for deviation

  //### Definition of HBOOK variables.

  const int iNTUPLE_PARS = 49;

#ifdef __HBOOK_FILES__

  // the order of variable names must macht the order
  // in the output ntuple below

  char *cvarnam [iNTUPLE_PARS] = {
    "n", "primary", "energy", "cored", "impact", "xcore", "ycore",
      "theta", "phi", "dangle", "dtheta", "dphi", "trigger", "ncphs",
      "nphes", "nphes2", "length", "width", "dist", "xdist", "azw",
      "miss", "alpha", "conc2", "conc3", "conc4", "conc5", "conc6",
      "conc7", "conc8", "conc9", "xmax", "ymax", "xm", "ym", "beta",
      "m2xy", "asymx", "asymy", "phiasym", "l1", "l2", "w1", "w2",
      "twidth", "tpeak", "tfirst", "tlast", "trange"};
  
  HBOOK_FILE ntupleFile;

#endif // __HBOOK_FILES__

  //### Definition of variables for |getopt()|.

  int ch, errflg = 0;        //@< used by getopt

  /*"### Beginning of the program.

    We start with the main program. First we (could) make some
    presentation, and follows the reading of the parameters file (now
    from the |stdin|), the reading of the CT parameters file, and the
    creation of the output file, where the processed data will be
    stored.
  **/

  //++
  // START
  //--

  // make unbuffered output
  cout.setf ( ios::stdio );

  //### Parameters files parsing.

  // parse command line options (see reflector.h)
  parname[0] = '\0';
  optarg = NULL;
  while ( !errflg &&
          ((ch = getopt(argc, argv, COMMAND_LINE_OPTIONS)) != -1) ) {
    switch (ch) {
    case 'f':
      strcpy(parname, optarg);
      break;
    case 'h':
      usage();
      break;
    default :
      errflg++;
    }
  }
  
  // show help if error
  if ( errflg>0 )
    usage();

  // make some sort of presentation
  present();

  // read parameters file
  if ( strlen(parname) < 1 )
    readparam(NULL);
  else
    readparam(parname);

  //### Initialization of parameters, and CT and pixels data files.

  // read data from file or from STDIN?
  Data_From_STDIN = get_data_from_stdin();

  // read PHE data?
  Read_Phe = get_read_phe();

  // read PHE data, generated previously with write_all_images?
  Read_Phe_All = get_read_phe_all();

  // write all images, even those without trigger?
  Write_All_Images = get_write_all_images();

  // write all data (i.e., ph.e.s in pixels)?
  Write_All_Data = get_write_all_data();

  // get filenames
  strcpy( inname, get_input_filename() );
  strcpy( outname, get_output_filename() );
  strcpy( datname, get_data_filename() );
  strcpy( hboname, get_hbook_filename() );
  strcpy( ct_filename, get_ct_filename() );

  // get different parameters of the simulation
  qThreshold   = get_threshold();
  qTailCut     = get_tail_cut();
  simulateNSB  = get_nsb( &meanNSB );
  onlyNSB      = get_nsb_only( &eventsNSB );
  countIslands = get_islands_cut( &nIslandsCut );

  // establish conditions for only NSB events (or not)
  if ( onlyNSB == TRUE )
    current_eventNSB = 0;
  else
    current_eventNSB = eventsNSB+1;

  // get trigger pattern to be used
  trigger_pattern_id = get_trigger_pattern_id();
  trigger_npatterns  = get_trigger_npatterns();
  trigger_patterns   = get_trigger_patterns();

  // get selections on the parameters
  Select_Energy = get_select_energy( &Select_Energy_le, &Select_Energy_ue);

  // get Single Phe. Spectrum mean, and compute normalized curve
  get_sps_params( sps_Mean, sps_FWHM, sps_Sigma );

  // log filenames information
  log(SIGNATURE,
      "%s:\n\t%20s:\t%s\n\t%20s:\t%s\n\t%20s:\t%s\n\t%20s:\t%s\n\t%20s:\t%s\n",
      "Filenames",
      "In", inname,
      "Out", outname,
      "Data", datname,
      "HBOOK", hboname,
      "CT", ct_filename);

  // log flags information
  log(SIGNATURE, "Flags:%20s: %s\n",
      "Data_From_STDIN",   ONoff(Data_From_STDIN));
  log(SIGNATURE, "Flags:%20s: %s\n",
      "Read_Phe",          ONoff(Read_Phe));
  log(SIGNATURE, "Flags:%20s: %s\n",
      "Read_Phe_All",      ONoff(Read_Phe_All));
  log(SIGNATURE, "Flags:%20s: %s\n",
      "Write_All_Images",  ONoff(Write_All_Images));
  log(SIGNATURE, "Flags:%20s: %s\n",
      "Write_All_Data",    ONoff(Write_All_Data));

  // NSB flags/data information
  log(SIGNATURE, "NSB:%20s: %10f %s\n",
      "NSB (phes/pixel)", meanNSB, ONoff(simulateNSB));
  log(SIGNATURE, "NSB:%20s: %10d %s\n",
      "NSB-only events",  eventsNSB, ONoff(onlyNSB));

  // log parameters information
  log(SIGNATURE, "Parameters:%20s: %f\n",
      "q0 (Threshold)", qThreshold);
  log(SIGNATURE, "Parameters:%20s: %f\n",
      "t0 (Tail-cut)", qTailCut);
  log(SIGNATURE, "Parameters:%20s: %f %s\n",
      "i0 (Islands-cut)", (float)nIslandsCut, ONoff(countIslands));

  // log SPS parameters
  log(SIGNATURE, "Single Phe. Spectrum:%20s: %f %s\n",
      "sps_Mean", sps_Mean, "ph.e-");
  log(SIGNATURE, "Single Phe. Spectrum:%20s: %f %s\n",
      "sps_FWHM", sps_FWHM, "ph.e-");
  log(SIGNATURE, "Single Phe. Spectrum:%20s: %f %s\n",
      "sps_Sigma", sps_Sigma, "ph.e-");
  
  // log selections
  log(SIGNATURE, "Selections:%20s: %s (%f:%f)\n", 
      "Energy", ONoff(Select_Energy), Select_Energy_le, Select_Energy_ue);

  // log random seeds 
  log(SIGNATURE, "Random Seeds: %ld %ld\n", 
      get_seeds(0), get_seeds(1)); 

  // set all random numbers seeds
  setall( get_seeds(0), get_seeds(1) );

  // get list of showers to evt. skip
  nSkip = get_nskip_showers();

  if (nSkip > 0) {
    Skip = new int[ nSkip ];
    get_skip_showers( Skip );

    log(SIGNATURE, "There are some showers to skip:\n");
    for (i=0; i<nSkip; ++i)
      log(SIGNATURE, "\tshower # %d\n", Skip[i]);
  }

  // read parameters from the ct.def file
  read_ct_file();

  // read pixels data
  read_pixels();

  // create Single Phe. Spectrum normalized curve
  create_sps( spsX, spsY, sps_Mean );

#ifdef __DEBUG__
  // dump data
  for (i=0; i<nSinglePheSpectrum; i++)
    cerr << setw(3) << i
         << setw(12) << spsX[i] << setw(12) << spsY[i] << endl;
#endif // __DEBUG__

  // set plate scale (deg/cm) and trigger area (deg)
  // plateScale_cm2deg = ( ct_Type == 0 ) ? (0.244/2.1) : (1.0/30.0);
  plateScale_cm2deg = ( ct_Type == 0 ) ? (0.244/2.1) : 0.030952381;

  if ( ! get_trigger_radius( &degTriggerZone ) )
    degTriggerZone = ( ct_Type == 0 ) ? (5.0) : (5.0);

  // set up the vector with flags about pixels in/out of the trigger
  int * inTrigger = new int[ ct_NPixels ];
  for ( i=0; i<ct_NPixels; ++i ) {
    if ( (sqrt(SQR(pixary[i][0]) + SQR(pixary[i][1]))*plateScale_cm2deg)
         > degTriggerZone )
      inTrigger[i] = FALSE; // outside the trigger zone
    else
      inTrigger[i] = TRUE;  // inside the trigger zone
  }

  if ( ! get_correction( &fCorrection ) )
    fCorrection = -1.0;

  // number of pixels for parameters
  anaPixels = get_ana_pixels();
  anaPixels = (anaPixels == -1) ? ct_NPixels : anaPixels;

  //### Definition of HBOOK parameters.

  // number of variables in n-tuple
  nvar = iNTUPLE_PARS;

#ifdef __HBOOK_FILES__

  // initialize hbook
  cts_vinit_hbook ();

  // open output ntuple
  ntupleFile.pname   = hboname;
  ntupleFile.pvarnam = cts_pget_varnam_str (cvarnam, iNTUPLE_PARS);
  ntupleFile.invar   = iNTUPLE_PARS;
  ntupleFile.ilrec   = 4096;
  ntupleFile.copt    = 'N';
  ntupleFile.ilun    = 20;
  ntupleFile.iid     = 1;

  cts_vopen_hbook_file (&ntupleFile);

  // set pointer for data
  image_data = ntupleFile.pevtdat;

#ifdef __PULSE_TIMING_PIXELS_FILES__

  HISTO pulseHisto;

#endif // __PULSE_TIMING_PIXELS_FILES__

#else  // __HBOOK_FILES__

  // set pointer for data
  image_data = new float[iNTUPLE_PARS];

#endif // __HBOOK_FILES__

  //### Definition of histograms for the timing.

  // allocate histograms for timing information

  // number of bins for general histograms and individual pixels
  iTime_nbins     = get_time_histo(&fTime_mintime, &fTime_maxtime);
  iTime_pnbins    = get_time_phisto(&fTime_pmintime, &fTime_pmaxtime);
  iTime_discnbins = get_time_dischisto(&fTime_discmintime, &fTime_discmaxtime);

  // number of time bins to be used in discriminator logic signal
  iTime_triggerbins = get_trigger_bins();

  // number of bins to use in the integration of the signal
  get_time_intgate(&nBefIntegBin, &nAftIntegBin);

  // histograms for individual pixels (ph.electron level)
  Histogram<float> **htime  = new Histogram<float>*[ct_NPixels];
  for (i=0; i<ct_NPixels; ++i) {
    sprintf(htimename,"Time distribution for pixel #%d", i+1);
    htime[i]  = new Histogram<float>(htimename,
                                     iTime_nbins,
                                     fTime_mintime, fTime_maxtime);
  }

  // histograms for individual pixels (voltage level)
  Histogram<float> **hpulse = new Histogram<float>*[ct_NPixels];
  for (i=0; i<ct_NPixels; ++i) {
    sprintf(htimename,"Time response for pixel #%d", i+1);
    hpulse[i] = new Histogram<float>(htimename,
                                     iTime_pnbins,
                                     fTime_pmintime, fTime_pmaxtime);
  }

  // histograms for individual pixels (trigger/discriminator level)
  Histogram<float> **htrigger = new Histogram<float>*[ct_NPixels];
  for (i=0; i<ct_NPixels; ++i) {
    sprintf(htimename,"Time response for pixel #%d", i+1);
    htrigger[i] = new Histogram<float>(htimename,
                                       iTime_discnbins,
                                       fTime_discmintime, fTime_discmaxtime);
  }

  float *imagepeaks = new float[ct_NPixels];

  // histogram with times for the whole shower
  Histogram<float> htimeshower("Time distribution for shower",
                               iTime_nbins,
                               fTime_mintime, fTime_maxtime);

  // histogram with times for the whole shower (after PMT)
  Histogram<float> htimeshower_conv("Time distribution after PMT for shower",
                                    iTime_pnbins,
                                    fTime_pmintime, fTime_pmaxtime);

  // histogram with discriminator output for the whole shower (coincidences)
  Histogram<float> hcoincidences("Coincidences histogram",
                                 iTime_discnbins,
                                 fTime_discmintime, fTime_discmaxtime);

  // histogram with widths of distributions
  Histogram<float> htimewidth("Width of Time distributions",
                              1000,
                              0.0, fTime_maxtime-fTime_mintime);

  // histogram with peak-times for all showers
  Histogram<float> htimepeak("Peak-Time distribution for shower",
                             iTime_nbins,
                             fTime_mintime, fTime_maxtime);

  // response of the PMTs
  // open file, depending on the telescope
  ifstream ifpulse;

  if ( ct_Type == 0 ) {
    //++ >>>>> CT1 <<<<<
    log( SIGNATURE, "Openning input PMT response file pulseCT1.dat\n");
    ifpulse.open("pulseCT1.dat");
    fTime_maxtime = 10.0; //ns
  } else {
    //++ >>>>> MAGIC <<<<<
    log( SIGNATURE, "Openning input PMT response file pulseMAGIC.dat\n");
    ifpulse.open("pulseMAGIC.dat");
    fTime_maxtime = 20.0; // ns
  }

  /*
  // create histogram for pulse
  Histogram<float> pmtpulse("PMT response", 200, 0.0, 5.0);

  // if file exists and there is no problem, then ok
  if ( ! ifpulse.good() )
    error( SIGNATURE, "Cannot open PMT response file pulse*.dat\n");

  // read header of the file
  for(i=0; i<6; i++)
    ifpulse.getline(dummy, 256);

  // read data for the pulse histogram (200 bins, see definition above)
  for(i=0; i<pmtpulse.get_nbins(); i++) {
    ifpulse >> u >> v;
    pmtpulse.fill(u, v, 0.0);
  }

  // close file
  ifpulse.close();
  */

  //### Opening and creation of files.

  // open input file if we DO read data from a file
  if (! Data_From_STDIN) {
    log( SIGNATURE, "Openning input \"rfl\" file %s\n", inname );
    inputfile.open( inname );
    if ( ! inputfile.good() )
      error( SIGNATURE, "Cannot open input file: %s\n", inname );
  }

  // get signature, and check it
  if ( Read_Phe )
    strcpy(Signature, SIGNATURE);
  else
    strcpy(Signature, REFL_SIGNATURE);

  strcpy(sign, Signature);

  read_bin_data( (char*)sign, strlen(Signature), Data_From_STDIN, inputfile);

  if (strcmp(sign, Signature) != 0) {
    cerr << "ERROR: Signature of .rfl file is not correct\n";
    cerr << '"' << sign << '"' << '\n';
    cerr << "should be: " << Signature << '\n';
    exit(1);
  }

  read_bin_data( (char*)sign, 1, Data_From_STDIN, inputfile);

  // open output file
  log( SIGNATURE, "Openning output \"phe\" file %s\n", outname );
  outputfile.open( outname );

  if ( ! outputfile.good() )
    error( SIGNATURE, "Cannot open output file: %s\n", outname );

  // open data file
  log( SIGNATURE, "Openning data \"dat\" file %s\n", datname );
  datafile.open( datname );

  if ( ! outputfile.good() )
    error( SIGNATURE, "Cannot open output file: %s\n", outname );

  // write signature
  outputfile.write( SIGNATURE, sizeof(SIGNATURE) );

  // initializes flag
  strcpy( flag, "                                        \0" );

  // allocate space for PMTs numbers of pixels
  fnpix = new float* [ iTime_pnbins ];
  for ( i=0; i<iTime_pnbins; ++i )
    fnpix[i] = new float [ ct_NPixels ];
  fnpixclean = new float [ ct_NPixels ];

  moments_ptr = moments( anaPixels, 0, 0, 0.0, 1, pixneig, npixneig );

  //### Main loop.

  // loop all over the file
  still_in_loop = TRUE;

  while ( ((! Data_From_STDIN) && (! inputfile.eof()))
          ||
          (Data_From_STDIN && still_in_loop)
          ||
          (current_eventNSB <= eventsNSB) ) {
    
    /*"
      We can read the data from the RFL files (standard behaviour), or
      from PHE files, which would contain already data processed
      previously with camera.\par

      In the later case, we only have to read the |mcevth|
      variable (MC Event Header) and the previously generated pixel
      image, i.e., we DO NOT need to re-map the photons into pixels
      (we don't have to repeat the pixelization process).
    **/

    if ( ! Read_Phe ) {

      if ( ! onlyNSB ) {
        
        // reading .rfl files (normal behaviour)
        
        // get flag, and calculate index
        read_bin_data( flag, SIZE_OF_FLAGS, Data_From_STDIN, inputfile);
        
        whatIs = (( isA( flag, FLAG_START_OF_EVENT )    ) +
                  ( isA( flag, FLAG_START_OF_RUN   ) << 1 ) +
                  ( isA( flag, FLAG_END_OF_EVENT   ) << 2 ) +
                  ( isA( flag, FLAG_END_OF_RUN     ) << 3 ) +
                  ( isA( flag, FLAG_END_OF_FILE    ) << 4 ) );
        
#ifdef __DEBUG__
        cerr << flag << ':';
#endif // __DEBUG__
        
      } else {
        
        // generating artificial NSB only events
        current_eventNSB++;
        
        if ( current_eventNSB <= eventsNSB ) {
          log(SIGNATURE, "Simulating NSB event number %d of %d . . .\n",
              current_eventNSB, eventsNSB);
          whatIs = 1;    // FLAG_START_OF_EVENT;
        } else {
          break;
        }
        
      }
      
    } else {
      
      // reading .phe files (ab-normal behaviour)
      whatIs = 1;     // FLAG_START_OF_EVENT;

    }
    
#ifdef __DEBUG__
    cerr << "whatIs = " << whatIs << endl << flush;
#endif // __DEBUG__
    
    // operate depending on the flag we read from the file
    
    switch ( whatIs ) {
      
    case 16:        // FLAG_END_OF_FILE
      
      log(SIGNATURE, "End of file . . .\n");
      still_in_loop  = FALSE;
      
      break;
      
    case 8:         // FLAG_END_OF_RUN
      
      ntshow += nshow;
      hidt = 0;
      
      log(SIGNATURE, "End of this run with %d events . . .\n", nshow);
      
      break;
      
    case 4:         // FLAG_END_OF_EVENT
      
      log(SIGNATURE, "End of this event: %d cphs(+%d). . .\n",
          ncph, ntcph);

      break;

    case 2:         // FLAG_START_OF_RUN

      nshow=0;

      break;

    case 1:         // FLAG_START_OF_EVENT

      /*"
        For the case |whatIs == 1|, which means |FLAG_START_OF_EVENT|,
        we read each Cherenkov photon, and follow these steps:
        
        @enumerate
        
        @- Transform XY-coordinates to IJ-coordinates.
        
        @- With this, we obtain the pixel where the photon hits.
        
        @- Use the wavelength $\lambda$ and the table of QE, and
        calculate the estimated (third order interpolated) quantum
        efficiency for that photon. The photon can be rejected.
        
        @- Use the overall efficiencies of Plexiglas window, Light
        guides and Collection on the First Dynode. The photon can be
        rejected.
        
        @- If accepted, then add it to the histogram of the pixel.
        
        @endenumerate
        
        If we are reading PHE files, we jump to the point where the
        pixelization process already has finished.
      **/
      
      ++nshow;
      
      if ( ! onlyNSB ) {

        // get MCEventHeader
        read_bin_data( (char*)&mcevth, mcevth.mysize(),
                       Data_From_STDIN, inputfile);

        // get times
        mcevth.get_times( &t0, &t1 );
        trange = 0.0;

        // get core position
        coreD = mcevth.get_core(&coreX, &coreY);

        // read the direction of the incoming shower
        thetashw = mcevth.get_theta();
        phishw = mcevth.get_phi();

        // read the deviation of the telescope with respect to the shower
        mcevth.get_deviations ( &thetaCT, &phiCT );

      } else {

        t0 = t1 = trange  = 0.;
        thetashw = phishw = 0.;
        thetaCT  = phiCT  = 0.;
        coreD     = 0.;

      }

      // calculate impact parameter (shortest distance betwee the original
      // trajectory of the primary (assumed shower-axis) and the
      // direction where the telescope points to
      //
      // we use the following equation, given that the shower core position
      // is (x1,y1,z1)=(x,y,0),the  trajectory is given by (l1,m1,n1),
      // and the telescope position and orientation are (x2,y2,z2)=(0,0,0)
      // and (l2,m2,n2)
      //
      //              |                     |
      //              | x1-x2  y1-y2  z1-z2 |
      //              |                     |
      //            + |   l1     m1     n1  |
      //            - |                     |
      //              |   l2     m2     n2  |
      //              |                     |
      // dist = ------------------------------------      ( > 0 )
      //         [ |l1 m1|2   |m1 n1|2   |n1 l1|2 ]1/2
      //         [ |     |  + |     |  + |     |  ]
      //         [ |l2 m2|    |m2 n2|    |n2 l2|  ]
      //
      // playing a little bit, we get this reduced for in our case:
      //
      //
      // dist = (- m2 n1 x + m1 n2 x + l2 n1 y - l1 n2 y - l2 m1 z + l1 m2 z) /
      //        [(l2^2 (m1^2 + n1^2) + (m2 n1 - m1 n2)^2 -
      //          2 l1 l2 (m1 m2 + n1 n2) + l1^2 (m2^2 + n2^2) ] ^(1/2)

      // calculate vector for shower
      l1 = sin(thetashw)*cos(phishw);
      m1 = sin(thetashw)*sin(phishw);
      n1 = cos(thetashw);

      if ( (thetaCT == 0.) && (phiCT == 0.) ) {

        // CT was looking to the source (both lines are parallel)
        // therefore, we calculate the impact parameter as the distance
        // between the CT axis and the core position
        impactD = dist_r_P( 0., 0., 0., l1, m1, n1, coreX, coreY, 0. );

      } else {

        // the shower comes off-axis
        
        // obtain with this the final direction of the CT
        thetaCT += thetashw;
        phiCT += phishw;

        // calculate vector for telescope
        l2 = sin(thetaCT)*cos(phiCT);
        m2 = sin(thetaCT)*sin(phiCT);
        n2 = cos(thetaCT);

        // calculate smallest distance between the two trajectories
        // num = (m1*n2*coreX - m2*n1*coreX + l2*n1*coreY - l1*n2*coreY);
        // den = (SQR(l1*m2 - l2*m1) +
        //    SQR(m1*n2 - m2*n1) +
        //    SQR(n1*l2 - n2*l1));
        // den = sqrt(den);
        // impactD = fabs(num)/den;

        // calculate smallest distance between the two trajectories
        u = (l2*coreX + m2*coreY) / (l1*l2 + m1*m2 + n1*n2);

        // calculate impact parameter
        impactD = sqrt(SQR(coreX-u*l1) + SQR(coreY-u*m1) + SQR(-u*n1));

      }

      // store impact parameter in event header
      mcevth.put_impact( impactD );

      // set extended number of this shower
      // hidt = (ntshow+nshow)*10;
      hidt = (ntshow+nshow);
      
      if ( ! Read_Phe ) {

#ifdef __DEBUG__
        cerr << "Clearing histograms...\n";
#endif // __DEBUG__

        // clear time histograms

        for (i=0; i<ct_NPixels; ++i)
          htime[i]->clear();

        for (i=0; i<ct_NPixels; ++i)
          hpulse[i]->clear();

        for (i=0; i<ct_NPixels; ++i)
          htrigger[i]->clear();

        hcoincidences.clear();

        htimeshower.clear();

        sprintf(htimename, "hti%d", hidt);
        htimeshower.set_name(htimename);

      }

      // increment total counter of showers
      ntcph += ncph;

      // reset per-run counter of showers
      ncph = 0;

      /*------------------------------------------------------------*
       *  block to execute in case of normal operation (! Read_Phe) *
       *------------------------------------------------------------*/

      if ( (! Read_Phe) && (! onlyNSB) ) {

        //++++++++++++++++++++++++++++++++++++++++++++++++++
        // Read_Phe == FALSE
        //- - - - - - - - - - - - - - - - - - - - - - - - -
        // That means normal behaviour: read photons and
        // "map" them into the pixels
        //--------------------------------------------------

        // initialize CPhoton
        cphoton.fill(0., 0., 0., 0., 0., 0., 0., 0.);

        // read the photons data to the output file
        read_bin_data( (char*)&cphoton, cphoton.mysize(),
                       Data_From_STDIN, inputfile);

        // t0 = cphoton.get_t();

        // loop over the photons

        while ( (cphoton.isA( FLAG_END_OF_EVENT ) != TRUE) ) {

          // increase number of photons
          ++ncph;

          /*"### Pixelization.

            In order to calculate the coordinates, we use the change
            of system described (should be described) in this program
            further below.

          **/

          //+++
          // Pixelization
          //---

          // get wavelength
          last_wl = wl;
          wl = cphoton.get_wl();

          if ( (wl > 600.0) || (wl < 290.0) )
            break;

          //--------------------------------------------------
          // get pixel ID for this photon

          cx = cphoton.get_x();
          cy = cphoton.get_y();

          nPMT = pixel_id( cx, cy );

          //--------------------------------------------------

          // check if outside the camera
          if ( (nPMT < 0) || (nPMT >= ct_NPixels) ) {

            // read next photon
            read_bin_data( (char*)&cphoton, cphoton.mysize(),
                           Data_From_STDIN, inputfile);

            // go to beginning of loop, the photon is lost
            continue;

          }

#ifdef __DEBUG__
          cout << "@#1 " << nshow << ' '
               << cx << ' ' << cy << ' ' << nPMT << endl;
#endif // __DEBUG__

#ifdef __QE__

          //### QE simulation.

          //+++
          // QE simulation
          //---

          // find data point to be used in Lagrange interpolation (-> k)
          qeptr = (float **)QE[nPMT];

          FindLagrange(qeptr,k,wl);

          // if random > quantum efficiency, reject it
          qe = Lagrange(qeptr,k,wl) / 100.0;

          if ( RandomNumber > qe ) {

            // read next photon
            read_bin_data( (char*)&cphoton, cphoton.mysize(),
                           Data_From_STDIN, inputfile);

            // go to beginning of loop
            continue;

          }

#endif // __QE__

#ifdef __EFFICIENCIES__

          //### Different efficiencies simulation.

          //+++
          // Different efficiencies simulation.
          //---

          if ( RandomNumber > overall_Efficiency ) {

            // read next photon
            read_bin_data( (char*)&cphoton, cphoton.mysize(),
                           Data_From_STDIN, inputfile);

            // go to beginning of loop
            continue;

          }

#endif // __EFFICIENCIES__


          //### Storing a photoelectron signal.

          //+++
          // Cphoton is accepted
          //---

#ifdef __DEBUG__
          cerr << "photon accepted\n";
#endif // __DEBUG__

          if ( ! Read_Phe ) {

            // save the time of this photon into the time histogram
            t = cphoton.get_t() - t0;

            // show error on negative time
            if (t < 0.0)
              cerr << "TIME: " << nshow << ' ' << t << endl << flush;

            // recalculate maximum time
            if (t > trange)
              trange = t;

#ifdef __DEBUG__
            cerr << "adding signal. . .\n";
#endif // __DEBUG__

            // [NOTE htimes]:
            // we substitute the original store in htime(htimeshower) and
            // posterior convolution by
            // store in htime(htimeshower) a single value and
            // store in hpulse(htimeshower_conv) a ph.e. signal

            htime[nPMT]->fill( t, 1.0 );
            htimeshower.fill( t, 1.0 );

            add_phe_signal( t, hpulse[nPMT], &htimeshower_conv,
                            spsX, spsY, sps_Sigma );

          }

          // read next photon
          read_bin_data( (char*)&cphoton, cphoton.mysize(),
                         Data_From_STDIN, inputfile);

        } // end-of-while there are still photons in this event

#ifdef __LINUX_INPUT__

        //** <warning> ***************************************************

        //****************************************
        // WARNING!!! this is a trick, to be used
        // only with input files coming from
        // Linux boxes and previous versions of
        // reflector files.
        // You should know that you are using
        // this at your own risk!!
        //****************************************

        read_bin_data( (char*)&cphoton, 4, Data_From_STDIN, inputfile);

        //** </warning> **************************************************

#endif // __LINUX_INPUT__

        // show number of photons
        log(SIGNATURE, "Event %6d(+%6d) : %10d Ch.photons . . .\n",
            nshow, ntshow, ncph);

        // skip it ?
        for ( i=0; i<nSkip; ++i ) {
          if (Skip[i] == (nshow+ntshow)) {
            i = -1;
            break;
          }
        }

        // if after the previous loop, the exit value of i is -1 then
        // the shower number is in the list of showers to be skipped
        if (i == -1) {
          log(SIGNATURE, "\t\tskipped!\n");
          continue;
        }

        // see [NOTE htimes] above
        // htimeshower_conv = htimeshower;
        // convolute( htimeshower, pmtpulse, htimeshower_conv );

        // save width of distribution in histogram
        htimewidth.fill( htimeshower.get_stdev(), 1.0 );

        // save time of peak in histogram
        htimeshower_conv.get_max();
        htimepeak.fill( htimeshower_conv.get_xmax(), 1.0 );

        /*"
          After reading all the Cherenkov photons for a given event,
          we have in the table of number of photons for each pixel
          only the 'raw' amount of Cherenkov photons @$n_p@$. Now, we
          should take this number as the mean value of the
          distribution of photons in that pixel @$p@$, following a
          Poisson distribution.

          @[ n_p \equiv \mu_p @]

          and with this number the amount of light coming from the
          shower is calculated @$\hat{n}_p@$.

          Then, we calculate the amount of Night Sky Background we
          must introduce in that pixel @$p@$. We calculate this using
          again a Poisson distribution with mean @$\mu_\mathrm{NSB}@$
          (defined in the |camera.h| file). The value of
          @$\mu_\mathrm{NSB}@$ is obtained from measurements. With
          this value, the amount of photons @$\hat{n}_\mathrm{NSB}@$
          coming from the Night Sky Background is calculated.

          Finally, the amount of photons for that pixels is:
          @[ \hat{n}_p^\mathrm{final} = \hat{n}_p + \hat{n}_\mathrm{NSB} @]
        **/

        // after reading all the photons, our camera is filled
        if ( ! onlyNSB ) {
          if ( Select_Energy ) {
            if (( mcevth.get_energy() < Select_Energy_le ) ||
                ( mcevth.get_energy() > Select_Energy_ue )) {
              log(SIGNATURE, "select_energy: shower rejected.\n");
              continue;
            }
          }
        }

      } // if ( (! Read_Phe) && (! onlyNSB) ) 

      /*------------------------------------------------------------*
       *  block to execute in case of reading PHE files             *
       *------------------------------------------------------------*/

      else if (! onlyNSB) { // code to execute if Read_Phe == TRUE

        //++++++++++++++++++++++++++++++++++++++++++++++++++
        // Read_Phe == TRUE
        //- - - - - - - - - - - - - - - - - - - - - - - - -
        // That means only read the image from
        // the input file (or STDIN)
        //--------------------------------------------------

        // if this shower gave trigger, there will be an
        // image of the shower in the file
        // otherwise, we just write this header to the
        // output file and go
        // there will be also an image, if the input .phe file
        // was generated with the option "write_all_images"

        if ( (mcevth.get_trigger() == TRUE) || (Read_Phe_All == TRUE) ) {

          // read image of the shower from the PHE file
          log(SIGNATURE, "Reading image...\n");

          // read next photon
          read_bin_data( (char*)fnpix, ct_NPixels * sizeof( float ),
                         Data_From_STDIN, inputfile);

          if ( Select_Energy ) {
            if (( mcevth.get_energy() < Select_Energy_le ) ||
                ( mcevth.get_energy() > Select_Energy_ue )) {
              log(SIGNATURE, "select_energy: shower rejected.\n");
              continue;
            }
          }

        } else {

          if ( Select_Energy ) {
            if (( mcevth.get_energy() < Select_Energy_le ) ||
                ( mcevth.get_energy() > Select_Energy_ue )) {
              log(SIGNATURE, "select_energy: shower rejected.\n");
              continue;
            }
          }

          // write MCEventHeader to output file
          outputfile.write( (char *)&mcevth, mcevth.mysize() );

          continue;

        }

        ntshow++;

      } // end code to execute if Read_Phe == TRUE

      /*"### NSB (Night Sky Background) simulation.
        
        Here we add the so called LONS (Light Of Night Sky) or
        NSB (Night-Sky Background) noise. The measured value is
        $F \approx 2  \times 10^{12}$ ph/m$^2$ s sr.
        
        The number used in the input parameters file should be the
        mean number of expected ph.e.s per pixel and ns!!!
        
        The estimated values are:
        
        @itemize
        
        @- |CT1|: ???
        
        @- |MAGIC|: {\bf NSB = 0.11 ph.e.s/pixel/ns}.
        
        @enditemize
      **/

#ifdef __NSB__

      //+++
      // NSB simulation
      //---

      if ( simulateNSB ) {

#ifdef __DEBUG__
        cerr << "NSB simulation\n";
#endif // __DEBUG__

        // we first calculate the mean number of expected ph.e.s
        // per pixel and time bin
        meanNSBperbin = meanNSB * htime[0]->get_binsize();

        // and then fill each time bin for each pixel with a random
        // (poisson) number of ph.e.s
        
        // first we fill the central and gap pixels
        for ( i=0; i<ct_NPixels_small+ct_NPixels_gap; ++i ) {
          for ( j=0; j<iTime_pnbins; ++j ) {

            nsb_added = static_cast<float>( ignpoi( meanNSBperbin ) );

            if (nsb_added > 0.0) {
              htime[i]->fill(j, nsb_added, 0.0);
              htimeshower.fill(j, nsb_added, 0.0);
              add_phe_signal( hpulse[i]->get_center(j),
                              hpulse[i], &htimeshower_conv, 
                              spsX, spsY, sps_Sigma, nsb_added ); 
            }
            
          }
        }

        // then the big ones (area = 4 x area_small_pixels)
        meanNSBperbin *= 4.;

        for ( i=ct_NPixels_small+ct_NPixels_gap; i<ct_NPixels; ++i ) {
          for ( j=0; j<iTime_pnbins; ++j ) {

            nsb_added = static_cast<float>( ignpoi( meanNSBperbin ) );

            if (nsb_added > 0.0) {
              htime[i]->fill(j, nsb_added, 0.0);
              htimeshower.fill(j, nsb_added, 0.0);
              add_phe_signal( hpulse[i]->get_center(j),
                              hpulse[i], &htimeshower_conv,
                              spsX, spsY, sps_Sigma, nsb_added ); 
            }
            
          }
        }

      }

#endif // __NSB__

      // if we want apply any kind of correction, we do it here.

#ifdef __DEBUG__
      cerr << "Correction\n";
#endif // __DEBUG__

      if ( fCorrection > 0. ) {
        for ( i=0; i<ct_NPixels; ++i ) {
          htime[i]->scale( fCorrection );
          hpulse[i]->scale( fCorrection );
        }
      }
      
      /*"### PMT response.
        
        We have first to apply the PMT response of the photo-detection
        device, and then look for the trigger condition.
        
        If there's trigger, then clean the image, calculate the
        islands statistics and the other parameters of the image
        (Hillas' parameters and so on).
      **/
      
      if ( ! Read_Phe ) {
        
#ifdef __DEBUG__
        cerr << "Convolute with PMT response\n";
#endif // __DEBUG__
        
        /*
          // convolute with response of the PMT
          
          for (i=0; i<ct_NPixels; ++i)
          convolute( *(htime[i]), pmtpulse, *(hpulse[i]) );
        */
        
        for ( i=0; i<ct_NPixels; ++i )
          for ( j=0; j<iTime_pnbins; ++j )
            fnpix[j][i] = (hpulse[i])->get_content(j);
        
      } // ! Read_Phe
      
#ifdef __TRIGGER__
      
      /*"### Trigger logic simulation.
        
        In the following block we look at the pixel contents, looking
        for pixels fulfilling the trigger condition. This condition,
        in this current version of the program, is the following:
        
        @itemize
        
        @- |CT1|: Two neighbour pixels with charge above the threshold
        @$q_0@$. For the old CT1 data, however, the trigger condition
        was 'any two pixels with charge above the threshold @$q_0@$'.
        
        @- |MAGIC|: A 'closed-packet' of four neighbour pixels, each
        of them with charge above the threshold @$q_0@$.
        
        @enditemize
        
        In the following figure you can find a sort of description
        about the meanning of 'closed-packet', for 4 pixels.
        
        This was the usual trigger used. Nevertheless, this program is
        able to use any trigger pattern pre-defined by the user.
        
        @F
        
        \begin{figure}[htbp]
        \begin{center}
        \includegraphics{closepck.eps}
        \caption{Meanning of the expression ``{\it close-packet}''}
        \label{fig:closepacket}
        \end{center}
        \end{figure}
        
        @F
        
      **/
      
      //++
      // TRIGGER LOGIC
      //--
      
      // A. First we create the DISCRIMINATOR SIGNALS
      //------------------------------------------------------------
      
#ifdef __DEBUG__
      cerr << "TRIGGER: Creating discriminator signals\n";
#endif // __DEBUG__
      
      for ( i=0; i<ct_NPixels; ++i ) {
        
        // only for those pixels who are in the trigger logic
        //    if (inTrigger[i] == TRUE) {
        
        for ( j=1; j<iTime_pnbins; ++j ) {
          
          // if the signal passes from BELOW q0 to ABOVE q0
          // in this time slice
          if ( ((hpulse[i])->get_content(j-1) < qThreshold) &&
               ((hpulse[i])->get_content(j) >= qThreshold) ) {
            
            // then create a logic signal with is 1 from the time
            // corresponding to the moment where inside this bin
            // we cross the threshold q0 (assumed the center of the bin)
            // the length of the signal will be 'iTime_triggerbins'
            
            x = (hpulse[i])->get_center(j);
            m = (htrigger[i])->get_nbin(x);
            
            for ( k=m; k<(m+iTime_triggerbins); ++k ) {
              (htrigger[i])->fill( k, 1.0, 0.0 );
              hcoincidences.fill( k, 1.0, 0.0 );
            }
            
          } // end-if passes from BELOW q0 to ABOVE q0
          
        } // j:[0,iTime_pnbins)
        
        // } // if inTrigger
        
      } // i:[0,ct_NPixels)


#ifdef __PULSE_TIMING_FILES__

      // save timing for whole shower

      sprintf(htimename, "hti%06d", hidt);
      htimeshower.save(htimename, "htimeshower");

      sprintf(htimename, "htp%06d", hidt);
      htimeshower_conv.save(htimename, "hpulseshower");

      sprintf(htimename, "htc%06d", hidt);
      hcoincidences.save(htimename, "hcoinc");

#ifdef __PULSE_TIMING_PIXELS_FILES__

      // save timing for individual pixels shower

      for ( i=0; i<ct_NPixels; i++) {

        // write photons histogram
        
        sprintf(htimename,
                "Photons histogram for shower %d, pixel %d", hidt, i+1);
        pulseHisto.phname = htimename;
        pulseHisto.iid    = (hidt * 10000) + (i + 1) + 1000;
        pulseHisto.ixbin  = (htime[i])->get_nbins();
        pulseHisto.iybin  = 0;
        pulseHisto.fxlow  = (htime[i])->get_lower();
        pulseHisto.fxhigh = (htime[i])->get_upper();
        pulseHisto.fylow  = 0.;
        pulseHisto.fyhigh = 0.;
        pulseHisto.fvmx   = 0.;

        cts_vbook_hist ( &pulseHisto );
          
        for ( j=0; j<(htime[i])->get_nbins(); j++ ) 
          cts_hfill ( pulseHisto.iid, (htime[i])->get_center(j), 0.f,
                      (htime[i])->get_content(j) );
        
        // write pulse histogram
        
        sprintf(htimename,
                "Pulse histogram for shower %d, pixel %d", hidt, i+1);
        pulseHisto.phname = htimename;
        pulseHisto.iid    = (hidt * 10000) + (i + 1) + 2000;
        pulseHisto.ixbin  = (hpulse[i])->get_nbins();
        pulseHisto.iybin  = 0;
        pulseHisto.fxlow  = (hpulse[i])->get_lower();
        pulseHisto.fxhigh = (hpulse[i])->get_upper();
        pulseHisto.fylow  = 0.;
        pulseHisto.fyhigh = 0.;
        pulseHisto.fvmx   = 0.;

        cts_vbook_hist ( &pulseHisto );
          
        for ( j=0; j<(hpulse[i])->get_nbins(); j++ ) 
          cts_hfill ( pulseHisto.iid, (hpulse[i])->get_center(j), 0.f,
                      (hpulse[i])->get_content(j) );
        
        // write trigger histogram
        
        sprintf(htimename,
                "Discriminator histogram for shower %d, pixel %d", hidt, i+1);
        pulseHisto.phname = htimename;
        pulseHisto.iid    = (hidt * 10000) + (i + 1) + 3000;
        pulseHisto.ixbin  = (htrigger[i])->get_nbins();
        pulseHisto.iybin  = 0;
        pulseHisto.fxlow  = (htrigger[i])->get_lower();
        pulseHisto.fxhigh = (htrigger[i])->get_upper();
        pulseHisto.fylow  = 0.;
        pulseHisto.fyhigh = 0.;
        pulseHisto.fvmx   = 0.;

        cts_vbook_hist ( &pulseHisto );
          
        for ( j=0; j<(htrigger[i])->get_nbins(); j++ ) 
          cts_hfill ( pulseHisto.iid, (htrigger[i])->get_center(j), 0.f,
                      (htrigger[i])->get_content(j) );
        
      }

      for ( i=0; i<ct_NPixels; i++) {

        j = (hidt * 10000) + (i + 1) + 1000;

        cts_hrout (j,        ntupleFile.ilun, &ntupleFile.copt);
        cts_hrout (j + 1000, ntupleFile.ilun, &ntupleFile.copt);
        cts_hrout (j + 2000, ntupleFile.ilun, &ntupleFile.copt);

      }
      
      for ( i=0; i<ct_NPixels; i++) {

        j = (hidt * 10000) + (i + 1) + 1000;

        cts_hdelet( j );
        cts_hdelet( j + 1000 );
        cts_hdelet( j + 2000 );

      }
      
#endif // __PULSE_TIMING_PIXELS_FILES__

#endif // __PULSE_TIMING_FILES__


      // B. Then, look for COINCIDENCES in the discriminator signals
      //------------------------------------------------------------

#ifdef __DEBUG__
      cerr << "TRIGGER: Looking for coincidences\n";
#endif // __DEBUG__

      // Warning! NOT all the camera is able to give trigger
      // only up to 'degTrigger' degrees

      // noverq0 = 0;
      q0 = qThreshold;
      trigger = FALSE;
      mxgrp = 0;
      maxcharge = 0.0;

      // loop on pixels
      // we will assume that the trigger area in formed only by
      // small pixels
      for ( i=0 ; (i<ct_NPixels_small) && (trigger==FALSE) ; ++i ) {

        // is this pixel inside the trigger zone in the camera ?
        if ( inTrigger[i] != TRUE )
          continue; // no, next pixel

        // loop on discriminator time slices
        for ( ntimebin=0 ;
              (ntimebin<iTime_discnbins*0.9) && (trigger==FALSE) ;
              ++ntimebin) {

          // is this pixel above threshold in this time slice ? =
          // = is the discriminator fired in this time slice ?
          if ( (htrigger[i])->get_content(ntimebin) < 1.0 )
            continue; // no, next time slice

          // it is: increment the number of pixels above threshold
          // THIS MIGHT NOT HAVE SENSE NOW!!!
          ++noverq0;

          // if the trigger already fired, just count the pixels
          // above threshold
          // if ( trigger == TRUE )
          //   continue;

          // check whether we have trigger
          if ( ct_Type == 0 ) {

            //++ >>>>> CT1 <<<<<

            // look at each pixel in the neighborhood, and count those
            // above threshold q0 'ngrpq0' is the number of neighbours
            // of pixel i with q > q0

            ngrpq0 = 0;

            for ( j=0 ; j<npixneig[i] && pixneig[i][j]>-1 ; ++j ) {
              if ( fnpix[ntimebin][pixneig[i][j]] >= q0 )
                ++ngrpq0;
            }

#ifdef __CT1_NO_NEIGHBOURS__
            if ( noverq0 > 1 ) trigger = TRUE;
#else
            if ( ngrpq0 > 0 ) trigger = TRUE;
#endif // __CT1_NO_NEIGHBOURS__

            //-- >>>>> CT1 <<<<<

          } else {

            //++ >>>>> MAGIC <<<<<

            triggerBits = pixel_bit_mask(i, q0, htrigger, ntimebin);
            //printf("Slice: %d , mask: %X\n", ntimebin, triggerBits);

            for ( j=0; j<trigger_npatterns; j++ ) {

              // if inside the triggerBits we find one of
              // the allowed trigger patterns => TRIGGER!!!

              if ((triggerBits & trigger_patterns[j]) == trigger_patterns[j])
                {
                  trigger = TRUE;
                  log(SIGNATURE,
                      "TRIGGER   pix# %3d  time-slice %4d (%6.2f-%6.2f ns)\n",
                      i, ntimebin,
                      (htrigger[i])->get_lower(ntimebin),
                      (htrigger[i])->get_upper(ntimebin));

                  break;
                }

            } // for each possible trigger pattern

          } // ct_Type

        } // for each time bin

      } // for each pixel i

      // novq0 = noverq0;

      tmpdeviation = mcevth.get_deviations (&dtheta, &dphi);
      tmpdeviation = isnan( tmpdeviation ) ? 0. : tmpdeviation;
        
      // we sum all the charge, in the interval
      // [ntimebin-nBefIntegBin, ntimebin+nAftIntegBin]

      if ( trigger == TRUE ) {

#ifdef __DEBUG__
        cerr << "TRIGGER:     TRIGGER!!!\n";
#endif // __DEBUG__

        itrigger = i;
        ++ntrigger;

        // convert bin in discrim. hist. to signal hist.
        x = (htrigger[i])->get_center(ntimebin);
        m = (hpulse[i])->get_nbin(x);

        nMinIntegBin = MAX( m - nBefIntegBin , 0 );
        nMaxIntegBin = MIN( m + nAftIntegBin, iTime_pnbins) + 1;

        for ( i=0; i<ct_NPixels; ++i ) {
          fnpixclean[i] = 0.0;
          for ( j=nMinIntegBin; j<nMaxIntegBin; ++j )
            fnpixclean[i] += (hpulse[i])->get_content(j);
        }

#ifdef __TAILCUT__

        //### Tail-cut condition.

#ifdef __DEBUG__
        cerr << "Tail-cut\n";
#endif // __DEBUG__

        //++
        // tail-cut
        //--

        // Tail-Cut = 0   : No Tail-Cut
        // Tail-Cut > 0   : Make Tail-Cut
        // Tail-Cut < 0   : Make Tail-Cut with t_0 = Sqrt[ maximum ]

        if (qTailCut > 0.0) {

          for ( i=0; i<ct_NPixels; ++i )
            if ( fnpixclean[i] < qTailCut )
              fnpixclean[i] = 0.0;

        } else if (qTailCut < 0.0) {

          maxcharge = sqrt(maxcharge);

          for ( i=0; i<ct_NPixels; ++i )
            if ( fnpixclean[i] < maxcharge )
              fnpixclean[i] = 0.0;

        }

#endif // __TAILCUT__

#ifdef __ISLANDS__

        //### Islands algorithm.

        //++
        // islands counting, and cleanning
        //--

#ifdef __DEBUG__
        cerr << "Islands\n";
#endif // __DEBUG__

        if ( countIslands ) {
          islands_ptr = islands( ct_NPixels_small, fnpixclean, pixneig,
                                 npixneig, countIslands, nIslandsCut);
        }

#endif // __ISLANDS__

#ifdef __MOMENTS__

        //### Calculation of parameters of the image.

        //++
        // moments calculation
        //--

#ifdef __DEBUG__
        cerr << "Moments (anaPixels=" << anaPixels << endl;
#endif // __DEBUG__

        // calculate moments and other things

        moments_ptr = moments( anaPixels, fnpixclean, pixary,
                               plateScale_cm2deg, 0,
                               pixneig, npixneig );

        charge = moments_ptr->charge ;
        smax   = moments_ptr->smax   ;
        maxs   = moments_ptr->maxs   ;
        nmaxs  = moments_ptr->nmaxs  ;
        length = moments_ptr->length ;
        width  = moments_ptr->width  ;
        dist   = moments_ptr->dist   ;
        xdist  = moments_ptr->xdist  ;
        azw    = moments_ptr->azw    ;
        miss   = moments_ptr->miss   ;
        alpha  = moments_ptr->alpha  ;
        conc   = moments_ptr->conc   ;
        asymx  = moments_ptr->asymx  ;
        asymx  = moments_ptr->asymx  ;
        phiasym= moments_ptr->phi;

        lenwid_ptr = lenwid( anaPixels, fnpixclean, pixary,
                             plateScale_cm2deg,
                             ct_PixelWidth_corner_2_corner_half);

        // be aware: here we use the side effect of ++
        // there are two possibilities of using the operator ++:
        // 1) a = ++i  : first increments i, then evaluates expresion
        // 2) a = i++  : first evaluates expresion, then increments i
        // we INTENTIONALLY use the second form

        i=0;
        image_data[i++] = hidt/10;
        image_data[i++] = mcevth.get_primary();
        image_data[i++] = mcevth.get_energy();
        image_data[i++] = coreD;
        image_data[i++] = impactD;
        image_data[i++] = coreX;
        image_data[i++] = coreY;
        image_data[i++] = mcevth.get_theta();
        image_data[i++] = mcevth.get_phi();
        image_data[i++] = tmpdeviation;
        image_data[i++] = dtheta;
        image_data[i++] = dphi;
        image_data[i++] = trigger;
        image_data[i++] = ncph;
        image_data[i++] = charge;
        image_data[i++] = smax;
        image_data[i++] = length;
        image_data[i++] = width;
        image_data[i++] = dist;
        image_data[i++] = xdist;
        image_data[i++] = azw;
        image_data[i++] = miss;
        image_data[i++] = alpha;
        image_data[i++] = conc[0];
        image_data[i++] = conc[1];
        image_data[i++] = conc[2];
        image_data[i++] = conc[3];
        image_data[i++] = conc[4];
        image_data[i++] = conc[5];
        image_data[i++] = conc[6];
        image_data[i++] = conc[7];
        image_data[i++] = moments_ptr->xmax   ;
        image_data[i++] = moments_ptr->ymax   ;
        image_data[i++] = moments_ptr->m1x    ;
        image_data[i++] = moments_ptr->m1y    ;
        image_data[i++] = moments_ptr->beta   ;
        image_data[i++] = moments_ptr->m2xy   ;
        image_data[i++] = asymx;
        image_data[i++] = asymy;
        image_data[i++] = phiasym;

        image_data[i++] = lenwid_ptr->length1;
        image_data[i++] = lenwid_ptr->length2;
        image_data[i++] = lenwid_ptr->width1;
        image_data[i++] = lenwid_ptr->width2;

        image_data[i++] = htimeshower.get_stdev();      // twidth
        image_data[i++] = htimeshower_conv.get_xmax();  // tpeak
        image_data[i++] = t0;                           // tfirst
        image_data[i++] = t1;                           // tlast
        image_data[i++] = trange;                       // trange

        // there should be "nvar" variables
        if ( i != nvar )
          error( SIGNATURE, "Wrong entry length for Ntuple (%d => %d).\n",
                 i, nvar);

#ifdef __HBOOK_FILES__

        // put data on to the n-tuple
        cts_hfn ( &ntupleFile );

#endif // __HBOOK_FILES__

        // put this information in the data file,
        datafile << ntrigger;
        for ( i=0; i<nvar; ++i )
          datafile << ' ' << image_data[i];

#endif // __MOMENTS__

        // put this information in the data file,
        if ( Write_All_Data ) {

          datafile << '\n' << -9999;
          for ( i=0; i<ct_NPixels; ++i )
            datafile << ' ' << fnpixclean[i];

          for ( i=0; i<ct_NPixels; ++i )
            (hpulse[i])->get_max();

          datafile << '\n' << -9998;
          for ( i=0; i<ct_NPixels; ++i )
            datafile << ' ' << (hpulse[i])->get_xmax();

        }

        datafile << endl;

        mcevth.set_trigger( TRUE );

      } else { // ( trigger == FALSE )

        // fill data array with sum of signal
        // (number of accumulated bins is iTime_triggerbins)
        for ( i=0; i<ct_NPixels; ++i ) {
          fnpixclean[i] = 0.0;
          for ( j=0; j<iTime_triggerbins; ++j )
            fnpixclean[i] += fnpix[j][i];
        }

        /*
          for ( i=0; i<ct_NPixels; ++i ) {
          fnpixclean[i] = (hpulse[i])->get_sum();
          }
        */

        i=0;
        image_data[i++] = hidt / 10;
        image_data[i++] = mcevth.get_primary();
        image_data[i++] = mcevth.get_energy();
        image_data[i++] = coreD;
        image_data[i++] = impactD;
        image_data[i++] = coreX;
        image_data[i++] = coreY;
        image_data[i++] = mcevth.get_theta();
        image_data[i++] = mcevth.get_phi();
        image_data[i++] = tmpdeviation;
        image_data[i++] = dtheta;
        image_data[i++] = dphi;
        image_data[i++] = trigger;
        image_data[i++] = ncph;
        image_data[i++] = -1.;
        image_data[i++] = -1.;
        image_data[i++] = -1.;
        image_data[i++] = -1.;
        image_data[i++] = -1.;
        image_data[i++] = -1.;
        image_data[i++] = -1.;
        image_data[i++] = -1.;
        image_data[i++] = -1.;
        image_data[i++] = -1.;
        image_data[i++] = -1.;
        image_data[i++] = -1.;
        image_data[i++] = -1.;
        image_data[i++] = -1.;
        image_data[i++] = -1.;
        image_data[i++] = -1.;
        image_data[i++] = -1.;
        image_data[i++] = -1.;
        image_data[i++] = -1.;
        image_data[i++] = -1.;
        image_data[i++] = -1.;
        image_data[i++] = -1.;
        image_data[i++] = -1.;
        image_data[i++] = -1.;
        image_data[i++] = -1.;
        image_data[i++] = -1.;

        image_data[i++] = -1.;
        image_data[i++] = -1.;
        image_data[i++] = -1.;
        image_data[i++] = -1.;

        image_data[i++] = -1.;
        image_data[i++] = -1.;
        image_data[i++] = -1.;
        image_data[i++] = -1.;
        image_data[i++] = -1.;

        // there should be "nvar" variables
        if ( i != nvar )
          error( SIGNATURE, "Wrong entry length for Ntuple (%d => %d).\n",
                 i, nvar);

#ifdef  __HBOOK_FILES__

        // put data on to the n-tuple
        cts_hfn ( &ntupleFile );

#endif // __HBOOK_FILES__

        // put this information in the data file,
        if ( Write_All_Data ) {
          
          datafile << ntrigger;
          for ( i=0; i<nvar; ++i )
            datafile << ' ' << image_data[i];
          
          datafile << '\n' << -9999;
          for ( i=0; i<ct_NPixels; ++i )
            datafile << ' ' << fnpixclean[i];

          for ( i=0; i<ct_NPixels; ++i )
            hpulse[i]->get_max();

          datafile << '\n' << -9998;
          for ( i=0; i<ct_NPixels; ++i )
            datafile << ' ' << hpulse[i]->get_xmax();

        }
        
        datafile << endl;
        
        mcevth.set_trigger( FALSE );
        
      } // trigger == FALSE
      
#endif // __TRIGGER__
      
      //### Save data.
      
      //++++++++++++++++++++++++++++++++++++++++++++++++++
      // we already have all information we want
      // the only thing we must do now is writing it to
      // the output file
      //--------------------------------------------------
      
      //++
      // save the image to the file
      //--
      
      // write MCEventHeader to output file
      outputfile.write( (char *)&mcevth, mcevth.mysize() );

#ifdef __TRIGGER__

      // save the image
      if ( (trigger == TRUE) || (Write_All_Images == TRUE) )
        outputfile.write( (char *) fnpix, ct_NPixels * sizeof( float ) );

#else

      // save the image
      outputfile.write( (char *) fnpix, ct_NPixels * sizeof( float ) );

#endif // __TRIGGER__

      break;

    } // switch ( whatIs )

  } // still data left

  //### End of program.

  // close remarks
  ntcph += ncph;
  
  log( SIGNATURE, "%d event(s), with a total of %d C.photons\n",
       ntshow, ntcph );
  log( SIGNATURE, "Fraction of triggers: %5.1f%% (%d out of %d)\n",
       ((float)ntrigger) / ((float)ntshow) * 100.0, ntrigger, ntshow);

  // close files
  log( SIGNATURE, "Closing files\n" );

  inputfile.close();
  outputfile.close();
  datafile.close();

  // histograms
  if ( ! Read_Phe ) {

    sprintf(htimename, "htime");
    htimepeak.save("htp------", "htimepeak");

    sprintf(htimename, "hwidth");
    htimewidth.save("htw------", "htimewidth");

  }

#ifdef __HBOOK_FILES__

  // write n-tuple to file & close it

  HISTO hdpeak  = {"Time peaks histogram", 101,
                     htimepeak.get_nbins(), 0,
                     htimepeak.get_lower(), htimepeak.get_upper(),
                     0.f, 0.f, 0.f};
  HISTO hdwidth = {"Widths histogram", 102,
                     htimewidth.get_nbins(), 0,
                     htimewidth.get_lower(), htimewidth.get_upper(),
                     0.f, 0.f, 0.f};

  cts_vbook_hist ( &hdpeak );
  for ( i=0; i<htimepeak.get_nbins(); i++ )
    cts_hfill ( hdpeak.iid, htimepeak.get_center(i), 0.f,
                htimepeak.get_content(i) );

  cts_vbook_hist ( &hdwidth );
  for ( i=0; i<htimepeak.get_nbins(); i++ )
    cts_hfill ( hdwidth.iid, htimewidth.get_center(i), 0.f,
                htimewidth.get_content(i) );

  cts_hrout (0, ntupleFile.ilun, &ntupleFile.copt);
  cts_hrend (&ntupleFile);

#endif // __HBOOK_FILES__

  // clean memory
  delete [] Skip;
  Skip = 0;

  delete [] image_data;
  image_data = 0;

  delete [] imagepeaks;
  imagepeaks = 0;

  for (i=0; i<ct_NPixels; i++) {
    delete htime[i];
    delete hpulse[i];
    htime[i] = 0;
    hpulse[i] = 0;
  }
  delete [] htime;
  delete [] hpulse;
  htime = 0;
  hpulse = 0;

  for (i=0; i<iTime_pnbins; i++) {
    delete [] fnpix[i];
    fnpix[i] = 0;
  }
  delete [] fnpix;
  fnpix = 0;

  delete [] fnpixclean;
  fnpix = 0;

  // program finished
  log( SIGNATURE, "Done.\n");

  return 0;
}
//}

// @T \newpage

//## Functions definition.

//!-----------------------------------------------------------
// @name present
//
// @desc Make some presentation
//
// @date Sat Jun 27 05:58:56 MET DST 1998
//------------------------------------------------------------
// @function

//{
void
present(void)
{
  cout << "##################################################\n"
       <<  SIGNATURE << '\n' << '\n'
       << "Processor of the reflector output\n"
       << "Kopyleft (K) 1998,1999,2000 J C Gonzalez\n"
       << "##################################################\n\n"
       << flush ;
}
//}


//!-----------------------------------------------------------
// @name usage
//
// @desc show help
//
// @date Tue Dec 15 16:23:30 MET 1998
//------------------------------------------------------------
// @function

//{
void
usage(void)
{
  present();
  cout << "\nusage ::\n\n"
       << "\t camera "
       << " [ -f paramfile ] "
       << " [ -h ] "
       << "\n\n or \n\n"
       << "\t camera < paramfile"
       << "\n\n";
  exit(0);
}
//}


//!-----------------------------------------------------------
// @name log
//
// @desc function to send log information
//
// @var    funct  Name of the caller function
// @var    fmt    Format to be used (message)
// @var    ...    Other information to be shown
//
// @date Sat Jun 27 05:58:56 MET DST 1998
//------------------------------------------------------------
// @function

//{
void
log(const char *funct, char *fmt, ...)
{
  va_list args;

  //  Display the name of the function that called error
  printf("[%s]: ", funct);

  // Display the remainder of the message
  va_start(args, fmt);
  vprintf(fmt, args);
  va_end(args);
}
//}


//!-----------------------------------------------------------
// @name error
//
// @desc function to send an error message, and abort the program
//
// @var    funct  Name of the caller function
// @var    fmt    Format to be used (message)
// @var    ...    Other information to be shown
//
// @date Sat Jun 27 05:58:56 MET DST 1998
//------------------------------------------------------------
// @function

//{
void
error(const char *funct, char *fmt, ...)
{
  va_list args;

  //  Display the name of the function that called error
  fprintf(stderr, "ERROR in %s: ", funct);

  // Display the remainder of the message
  va_start(args, fmt);
  vfprintf(stderr, fmt, args);
  va_end(args);

  perror(funct);

  abort();
}
//}


//!-----------------------------------------------------------
// @name isA
//
// @desc returns TRUE(FALSE), if the flag is(is not) the given
//
// @var    s1   String to be searched
// @var    flag   Flag to compare with string s1
// @return TRUE: both strings match; FALSE: oth.
//
// @date Wed Jul  8 15:25:39 MET DST 1998
//------------------------------------------------------------
// @function

//{
int
isA( char * s1, const char * flag ) {
  return ( (strncmp((char *)s1, flag, 8)==0) ? TRUE : FALSE );
}
//}


//!-----------------------------------------------------------
// @name read_ct_file
//
// @desc read CT definition file
//
// @date Sat Jun 27 05:58:56 MET DST 1998
//------------------------------------------------------------
// @function

//{
void
read_ct_file(void)
{
  char line[LINE_MAX_LENGTH];  //@< line to get from the ctin
  char token[ITEM_MAX_LENGTH];   //@< a single token
  int i, j;      //@< dummy counters

  // variables for check purposes
  int ct_npixels_small;    //@< number of small pixels
  int ct_npixels_gap;    //@< number of gap pixels
  int ct_npixels_big;    //@< number of big pixels
  int ct_npixels;    //@< total number of pixels

  log( "read_ct_file", "start.\n" );

  ifstream ctin ( ct_filename );

  if ( ! ctin.good() )
    error( "read_ct_file",
           "Cannot open CT def. file: %s\n", ct_filename );

  // loop till the "end" directive is reached

  int is_end = FALSE;
  while (!ctin.eof()) {

    // get line from stdin

    ctin.getline(line, LINE_MAX_LENGTH);

    // look for each item at the beginning of the line

    for (i=0; i<=define_mirrors; i++)
      if (strstr(line, CT_ITEM_NAMES[i]) == line)
        break;

    // if it is not a valid line, just ignore it

    if (i == define_mirrors+1)
      continue;

    // case block for each directive

    switch ( i ) {

    case type:          // <type of telescope> (0:CT1  1:MAGIC)

      // get focal distance

      sscanf(line, "%s %d", token, &ct_Type);

      log( "read_ct_file", "<Type of Telescope>: %s\n",
           ((ct_Type==0) ? "CT1" : "MAGIC") );

      break;

    case focal_distance:      // <focal distance> [cm]

      // get focal distance

      sscanf(line, "%s %f", token, &ct_Focal_mean);

      log( "read_ct_file", "<Focal distance>: %f cm\n", ct_Focal_mean );

      break;

    case focal_std:       // s(focal distance) [cm]

      // get focal distance

      sscanf(line, "%s %f", token, &ct_Focal_std);

      log( "read_ct_file", "s(Focal distance): %f cm\n", ct_Focal_std );

      break;

    case point_spread:        // <point spread> [cm]

      // get point spread

      sscanf(line, "%s %f", token, &ct_PSpread_mean);

      log( "read_ct_file", "<Point spread>: %f cm\n", ct_PSpread_mean );

      break;

    case point_std:       // s(point spread) [cm]

      // get point spread

      sscanf(line, "%s %f", token, &ct_PSpread_std);

      log( "read_ct_file", "s(Point spread): %f cm\n", ct_PSpread_std );

      break;

    case adjustment_dev:      // s(adjustment_dev) [cm]

      // get point spread

      sscanf(line, "%s %f", token, &ct_Adjustment_std);

      log( "read_ct_file", "s(Adjustment): %f cm\n", ct_Adjustment_std );

      break;

    case black_spot:        // radius of the black spot in the center [cm]

      // get black spot radius

      sscanf(line, "%s %f", token, &ct_BlackSpot_rad);

      log( "read_ct_file", "Radius of the black spots: %f cm\n",
           ct_BlackSpot_rad);

      break;

    case r_mirror:        // radius of the mirrors [cm]

      // get radius of mirror

      sscanf(line, "%s %f", token, &ct_RMirror);

      log( "read_ct_file", "Radii of the mirrors: %f cm\n", ct_RMirror );

      break;

    case n_mirrors:       // number of mirrors

      // get the name of the output_file from the line

      sscanf(line, "%s %d", token, &ct_NMirrors);

      log( "read_ct_file", "Number of mirrors: %d\n", ct_NMirrors );

      break;

    case camera_width:        // camera width [cm]

      // get the name of the ct_file from the line

      sscanf(line, "%s %f", token, &ct_CameraWidth);
      ct_CameraWidth_2 = ct_CameraWidth / 2.0;

      log( "read_ct_file", "Camera width: %f cm\n", ct_CameraWidth );

      break;

    case n_rings:      // number of rings

      // get the name of the output_file from the line

      sscanf(line, "%s %d %d", token, &ct_NRings_small, &ct_NRings_big);

      ct_NPixels_small = SumNumPixelInRings( ct_NRings_small );

      ct_NPixels_gap = (ct_NRings_big-1)*6;

      ct_NBig1 = (ct_NRings_small + 1) / 2;

      ct_NPixels_big = (ct_NBig1 + (ct_NBig1 + ct_NRings_big - 1))
        * ct_NRings_big / 2 * 6;

      ct_NPixels = ct_NPixels_small + ct_NPixels_gap + ct_NPixels_big;

      log("read_ct_file", "Number of rings: %d (small) %d (big)\n",
          ct_NRings_small, ct_NRings_big);

      break;

    case n_pixels:       // number of pixels

      // get the name of the output_file from the line

      sscanf(line, "%s %d %d %d", token,
             &ct_npixels_small, &ct_npixels_gap, &ct_npixels_big);

      ct_npixels = ct_npixels_small + ct_npixels_gap + ct_npixels_big;

      log("read_ct_file", "Number of pixels: %d+%d+%d = %d\n",
          ct_npixels_small, ct_npixels_gap, ct_npixels_big, ct_npixels );

      break;

    case pixel_width:       // pixel width [cm]

      // get the name of the ct_file from the line

      sscanf(line, "%s %f", token, &ct_PixelWidth);

      ct_PixelWidth_corner_2_corner = ct_PixelWidth / cos(RAD(30.0));
      ct_PixelWidth_corner_2_corner_half =
        ct_PixelWidth_corner_2_corner * 0.50;
      ct_Apot = ct_PixelWidth / 2;
      ct_2Apot = ct_Apot * 2.0;

      log( "read_ct_file", "Pixel width: %f cm\n", ct_PixelWidth );

      break;

    case define_mirrors:      // read table with the parameters of the mirrors

      log( "read_ct_file", "Table of mirrors data:\n" );

      // check whether the number of mirrors was already set

      if ( ct_NMirrors == 0 )
        error( "read_ct_file", "NMirrors was not set.\n" );

      // allocate memory for paths list

      log( "read_ct_file", "Allocating memory for ct_data\n" );

      ct_data = new float*[ct_NMirrors];

      for (i=0; i<ct_NMirrors; i++)
        ct_data[i] = new float[CT_NDATA];

      // read data

      log( "read_ct_file", "Reading mirrors data...\n" );

      for (i=0; i<ct_NMirrors; i++)
        for (j=0; j<CT_NDATA; j++)
          ctin >> ct_data[i][j];

      break;

    } // switch ( i )

  } // while (! is_end)

  // end

  // check number of pixels
  if (ct_NPixels != ct_npixels) {
    log("read_ct_file",
        "Inconsistency found: number of pixels wrong!\n");
    error("read_ct_file",
          "Check your CT definition file.\n");
  }

  log( "read_ct_file", "done.\n" );

  return;
}
//}


//!-----------------------------------------------------------
// @name dist_r_P
//
// @desc distance straight line r - point P
//
// @var a   Coord.X of point in straight line
// @var b   Coord.Y of point in straight line
// @var c   Coord.Z of point in straight line
// @var l   Dir.cos. in X axis
// @var m   Dir.cos. in Y axis
// @var n   Dir.cos. in Z axis
// @var x   Coord.X of problem point
// @var y   Coord.Y of problem point
// @var z   Coord.Z of problem point
// @return    Distance straight line r -- point P
//
// @date Sat Jun 27 05:58:56 MET DST 1998
//------------------------------------------------------------
// @function

//{
static float
dist_r_P(float a, float b, float c,
         float l, float m, float n,
         float x, float y, float z)
{
  return (
          sqrt((SQR((a-x)*m-(b-y)*l) +
                SQR((b-y)*n-(c-z)*m) +
                SQR((c-z)*l-(a-x)*n))/
               (SQR(l)+SQR(m)+SQR(n))
               )
          );
}
//}


//## Read/create the file |pixels.dat|.


//!-----------------------------------------------------------
// @name read_pixels
//
// @desc read pixels data
//
// @date Fri Mar 12 16:33:34 MET 1999
//------------------------------------------------------------
// @function

//{
void
read_pixels(void)
{
  ifstream pixfile, qefile;
  char line[LINE_MAX_LENGTH];
  int n, i, j, k;
  float x, y, qe;

  //------------------------------------------------------------
  // first, pixels' coordinates

  // initialize pixel numbers
  for ( i=0; i<PIX_ARRAY_SIDE; ++i )
    for ( j=0; j<PIX_ARRAY_SIDE; ++j )
      pixels[i][j] = -1;

  pixary = new float* [2*ct_NPixels];
  for ( i=0; i<2*ct_NPixels; ++i )
    pixary[i] = new float[2];

  pixneig = new int* [ct_NPixels_small];
  for ( i=0; i<ct_NPixels_small; ++i ) {
    pixneig[i] = new int[6];
    for ( j=0; j<6; ++j )
      pixneig[i][j] = -1;
  }

  npixneig = new int[ct_NPixels_small];
  for ( i=0; i<ct_NPixels_small; ++i )
    npixneig[i] = 0;

  // try to open the file
  log("read_pixels", "Openning the file \"%s\" . . .\n", PIXELS_FILE);

  pixfile.open( PIXELS_FILE );

  // if it is wrong or does not exist, go away
  if ( ! pixfile.good() ) {

    log("read_pixels", "*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n");
    log("read_pixels", "Cannot open \"%s\"\n", PIXELS_FILE);
    log("read_pixels", "Trying to create it, and get the data. . .\n");

    pixfile.close();

    create_pixels();

    log("read_pixels", "Succeded.\n");
    log("read_pixels", "*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n");

    // correct coordinates: scale to real pixel size

    for (i=0; i<ct_NPixels; i++) {
      pixary[i][0] *= ct_PixelWidth;
      pixary[i][1] *= ct_PixelWidth;
    }

  } else {

    // read file
    log("read_pixels", "Reading data . . .\n");

    n=0;
    while ( ! pixfile.eof() ) {

      // get line from the file
      pixfile.getline(line, LINE_MAX_LENGTH);

      // skip if comment
      if ( *line == '#' )
        continue;

      // get the value (dx, dy)
      sscanf(line, "%ld %d %d %d %f %f", &n, &i, &j, &k, &x, &y);

      if (n<0) break;

      // we read the coordinates (i,j,k), but the 'k' is thrown away
      // (the three coord. are not independent, i+j+k=0)

      // WARNING!! The pixel coordinates are normalized to a
      // hypothetical camera with Pixel Diameter = 1
      // In order to use the right coordinates, we must multiply them
      // by ct_PixelWidth

      x *= ct_PixelWidth;
      y *= ct_PixelWidth;

      if (n<1000) {

        // save the values to the array
        pixels[i+PIX_ARRAY_HALF_SIDE][j+PIX_ARRAY_HALF_SIDE] = n-1;
        pixary[n-1][0] = x;
        pixary[n-1][1] = y;

      } else {

        // save the values to the array
        pixels[i+PIX_ARRAY_HALF_SIDE][j+PIX_ARRAY_HALF_SIDE] = n;

      }

#ifdef __DEBUG__
      cout << "Read " << n << ' ' << i << ' ' << j << ' ' << k << ' '
           << x << ' ' << y << endl;
#endif

    }

    // close file
    pixfile.close();

  }

#ifdef __DEBUG__

  for (i=0; i<ct_NPixels; i++)
    printf("%4d %10g %10g\n", i, pixary[i][0], pixary[i][1]);

  for (i=0; i<PIX_ARRAY_SIDE; i++) {
    printf("## ");
    for (j=0; j<PIX_ARRAY_SIDE; j++)
      printf(" %10d", pixels[i][j]);
    printf("\n");
  }

#endif

  // calculate tables of neighbours
  for ( n=0 ; n<ct_NPixels_small ; ++n ) {
#ifdef __DEBUG__
    cout << "Para el pixel " << n << ": ";
#endif // ! __DEBUG__
    for ( i=n+1 ; (i<ct_NPixels_small)&&(npixneig[n]<6) ; ++i) {
      if ( pixels_are_neig(n,i) ) {
        pixneig[n][npixneig[n]] = i;
        pixneig[i][npixneig[i]] = n;
#ifdef __DEBUG__
        cout << i << ' ';
#endif // ! __DEBUG__
        ++npixneig[n];
        ++npixneig[i];
      }
    }
#ifdef __DEBUG__
    cout << endl << flush;
#endif // ! __DEBUG__
  }

#ifdef __DEBUG__
  for ( n=0 ; n<ct_NPixels_small ; ++n ) {
    cout << n << ':';
    for ( j=0; j<npixneig[n]; ++j)
      cout << ' ' << pixneig[n][j];
    cout << endl << flush;
  }
#endif // __DEBUG__

  //------------------------------------------------------------
  // second, pixels' QE

  // try to open the file
  log("read_pixels", "Openning the file \"%s\" . . .\n", QE_FILE);

  qefile.open( QE_FILE );

  // if it is wrong or does not exist, go away
  if ( ! qefile.good() )
    error( "read_pixels", "Cannot open \"%s\". Exiting.\n", QE_FILE );

  // read file
  log("read_pixels", "Reading QE data . . .\n");

  i=-1;

  while ( ! qefile.eof() ) {

    // get line from the file
    qefile.getline(line, LINE_MAX_LENGTH);

    // skip if comment
    if ( *line == '#' )
      continue;

    // if it is the first valid value, it is the number of QE data points
    if ( i < 0 ) {

      // get the number of datapoints
      sscanf(line, "%d", &pointsQE);

      // allocate memory for the table of QEs
      QE = new float ** [ct_NPixels];

      for ( i=0; i<ct_NPixels; ++i ) {
        QE[i] = new float * [2];
        QE[i][0] = new float[pointsQE];
        QE[i][1] = new float[pointsQE];
      }

      QElambda = new float [pointsQE];

      for ( i=0; i<pointsQE; ++i ) {
        qefile.getline(line, LINE_MAX_LENGTH);
        sscanf(line, "%f", &QElambda[i]);
      }

      i=0;

      continue;
    }

    // get the values (num-pixel, num-datapoint, QE-value)
    sscanf(line, "%d %d %f", &i, &j, &qe);

    if ( ((i-1) < ct_NPixels) && ((i-1) > -1) &&
         ((j-1) < pointsQE)   && ((j-1) > -1) ) {
      QE[i-1][0][j-1] = QElambda[j-1];
      QE[i-1][1][j-1] = qe;
    }

  }

  // close file
  qefile.close();

  // end
  log("read_pixels", "Done.\n");

}
//}


//!-----------------------------------------------------------
// @name create_pixels
//
// @desc create pixels data file
//
// @date Fri Mar 12 16:33:34 MET 1999
//------------------------------------------------------------
// @function

//{
void
create_pixels(void)
{

  // look: shorcuts are defined in file camera.h

  // we create the file PIXELS_FILE assuming a pixel edge-to-edge size of 1.0

  const float ct_local_PixelWidth = 1.0;
  const float ct_local_PixelWidth_corner_2_corner = ct_local_PixelWidth/COS30;
  const float ct_local_PixelWidth_corner_2_corner_half =
    ct_local_PixelWidth_corner_2_corner/2;
  const float ct_local_Apot = ct_local_PixelWidth/2;
  // const float ct_local_2Apot = 2.0*ct_local_Apot;

  int i, j, k;
  int ki, kj, kk, kstatic;

  float x, y, dx, dy;
  int ntot, nhalf;

  float fi, fj, fk;
  float nx, ny;

  float  d1 = ct_local_PixelWidth_corner_2_corner_half;
  float cd1 = d1 * COS30;
  float sd1 = d1 * SIN30;

  float  d2 = 1.2*ct_local_PixelWidth_corner_2_corner_half;
  float cd2 = d2 * COS30;
  float sd2 = d2 * SIN30;

  int n=0;

  float *pki;
  float *pkj;
  float *pkk;
  float *px ;
  float *py ;

  pki = new float [ ct_NPixels ];
  pkj = new float [ ct_NPixels ];
  pkk = new float [ ct_NPixels ];
  px  = new float [ ct_NPixels ];
  py  = new float [ ct_NPixels ];

  ofstream pixfile( "pixels-real.dat" );

  //------------------------------------------------------------

  for (i=0; i<PIX_ARRAY_SIDE; i++)
    for (j=0; j<PIX_ARRAY_SIDE; j++)
      pixels[i][j] = -1;

  // open new file
  log("create_pixels", "Creating the file \"%s\" . . .\n", PIXELS_FILE);

  // pixfile.open( "pixels-real.dat" );

  pixfile << "#--------------------------------------------------\n";
  pixfile << "# " << PIXELS_FILE << " -- pixels IDs + coordinates\n";
  pixfile << "#\n";
  pixfile << "# Kopyleft (K) 2000 J C Gonzalez\n";
  pixfile << "# Automatically generated by camera program\n";
  pixfile << "#--------------------------------------------------\n#\n";

  // (i) generate coordinates of small, central pixels
  //------------------------------------------------------------

  log("create_pixels", "Creating %d small pixels . . .\n", ct_NPixels_small);

  pixfile << "#-- small pixels ----------------------------------\n";

  Make_Pixel(0, 0., 0., 0, 0, 0);
  Map_Pixel(0, 0, 0);

  pixfile << setw(4) << 1
          << setw(4) << 0 << setw(4) << 0 << setw(4) << 0
          << setw(12) << 0. << setw(12) << 0. << endl;

  dx = ct_local_PixelWidth / 2.0;
  dy = ct_local_PixelWidth_corner_2_corner_half * 1.5;

  n++;
  for ( int iring=1; iring<ct_NRings_small+1; iring++ ) {

    if ( n != FirstInRing(iring) )
      error("create_pixels",
            "Variable n must be first pixel in %d ring, but is %d\n",
            FirstInRing(iring), n);

    ntot  = NumPixelsInRing(iring);
    nhalf = ntot/2;

    ki = iring;
    kj = -ki;
    kk = 0;
    kstatic = 0;

    int * iki = new int [ ntot ];
    int * ikj = new int [ ntot ];
    int * ikk = new int [ ntot ];

    for (k=0; k<nhalf; k++) {

      if ( kstatic > iring ) ki--;

      kstatic++;

      iki[k] = ki;

      iki[k+nhalf]  = -iki[k];
    }

    for (k=1; k<ntot; k++) {
      ikj[ntot-k] = -iki[k];
    }
    ikj[0] = -iki[0];

    for (k=0; k<ntot; k++) {
      ikk[k] = -(iki[k]+ikj[k]);
    }

    for (k=0; k<ntot; k++) {

      ki = iki[k];
      kj = ikj[k];
      kk = ikk[k];

      hex2coord(ki, kj, kk, x, y, ct_local_PixelWidth_corner_2_corner_half);

      pixfile << setw(4) << n+1
              << setw(4) << ki << setw(4) << kj << setw(4) << kk
              << setw(12) << x << setw(12) << y << endl;

      Make_Pixel( n, x, y, ki, kj, kk);
      Map_Pixel(ki, kj, n);

      n++;
    }

    delete [] iki;
    delete [] ikj;
    delete [] ikk;

  }

  // (ii) generate coordinates for gap pixels
  //------------------------------------------------------------

  log("create_pixels", "Creating %d gap pixels . . .\n", ct_NPixels_gap);

  pixfile << "#-- gap pixels ------------------------------------\n";

  // loop on number of gap pixels each corner
  for (i=1; i<ct_NRings_big; i++) {

    int inc = i*2;

    k = FirstInRingSector(ct_NRings_small,0);
    pki[n] = pki[k] + inc;
    pkj[n] = pkj[k] - inc;
    pkk[n] = pkk[k];

    n++;

    k = FirstInRingSector(ct_NRings_small,1);
    pki[n] = pki[k] + inc;
    pkj[n] = pkj[k];
    pkk[n] = pkk[k] - inc;

    n++;

    k = FirstInRingSector(ct_NRings_small,2);
    pki[n] = pki[k];
    pkj[n] = pkj[k] + inc;
    pkk[n] = pkk[k] - inc;

    n++;

    for (j=0; j<3; j++) {
      pki[n] = -pki[n-3];
      pkj[n] = -pkj[n-3];
      pkk[n] = -pkk[n-3];
      n++;
    }

  }

  for (k=0; k<ct_NPixels_gap; k++) {

    n = ct_NPixels_small + k;
    ki = int( pki[n] );
    kj = int( pkj[n] );
    kk = int( pkk[n] );

    hex2coord(ki, kj, kk, x, y, ct_local_PixelWidth_corner_2_corner_half);

    px[n] = x;
    py[n] = y;

    pixfile << setw(4) << n+1
            << setw(4) << ki << setw(4) << kj << setw(4) << kk
            << setw(12) << x << setw(12) << y << endl;

    Map_Pixel(ki, kj, n);


  }

  // (iii) generate big pixels coordinates
  //------------------------------------------------------------

  log("create_pixels", "Creating %d big pixels . . .\n", ct_NPixels_big);

  pixfile << "#-- big pixels ------------------------------------\n";

  fi = fj = fk = 0.;
  n = ct_NPixels_small+ct_NPixels_gap;

  k = FirstInRingSector(ct_NRings_small,0);

  // loop on ring of big pixels
  for (i=0; i<ct_NRings_big; i++) {

    x = px[k] + 2 * (i+1) * ct_local_PixelWidth;
    y = py[k] - ct_local_PixelWidth_corner_2_corner_half;

    for (j=0; j<(ct_NBig1+i); j++) {

      x -= ct_local_PixelWidth;
      y += 3. * ct_local_PixelWidth_corner_2_corner_half;

      xy2ijk( x, y, fi, fj, fk, 1.5*ct_local_PixelWidth_corner_2_corner_half);
      Make_Pixel( n,         x,  y, fi, fj, fk );

      ijk2xy(-fj,-fk,-fi, nx, ny, ct_local_PixelWidth_corner_2_corner_half);
      Make_Pixel( n+  (ct_NBig1+i), nx, ny,-fj,-fk,-fi );

      ijk2xy( fk, fi, fj, nx, ny, ct_local_PixelWidth_corner_2_corner_half);
      Make_Pixel( n+2*(ct_NBig1+i), nx, ny, fk, fi, fj );

      ijk2xy(-fi,-fj,-fk, nx, ny, ct_local_PixelWidth_corner_2_corner_half);
      Make_Pixel( n+3*(ct_NBig1+i), nx, ny,-fi,-fj,-fk );

      ijk2xy( fj, fk, fi, nx, ny, ct_local_PixelWidth_corner_2_corner_half);
      Make_Pixel( n+4*(ct_NBig1+i), nx, ny, fj, fk, fi );

      ijk2xy(-fk,-fi,-fj, nx, ny, ct_local_PixelWidth_corner_2_corner_half);
      Make_Pixel( n+5*(ct_NBig1+i), nx, ny,-fk,-fi,-fj );

      n++;

    }

    n+=5*(ct_NBig1+i);

  }

  k=0;

  n = ct_NPixels_small+ct_NPixels_gap;

  for (i=0; i<ct_NRings_big; i++) {

    for (j=0; j<6*(ct_NBig1+i); j++) {

      fi = pki[n];
      fj = pkj[n];
      fk = pkk[n];
      x  = px[n];
      y  = py[n];

      if ((j/(ct_NBig1+i))%2 == 0) {

        // map also the three small hexagons inside the big one

        coord2hex( x  , y+d1 , ki, kj, kk,
                   1.5*ct_local_PixelWidth_corner_2_corner_half);
        Map_Pixel(ki, kj, n);
        pixfile << setw(4) << n+1
                << setw(4) << ki << setw(4) << kj << setw(4) << kk
                << setw(12) << x << setw(12) << y << endl;

        coord2hex( x-cd1, y-sd1, ki, kj, kk,
                   1.5*ct_local_PixelWidth_corner_2_corner_half);
        Map_Pixel(ki, kj, n);
        pixfile << setw(4) << n+1
                << setw(4) << ki << setw(4) << kj << setw(4) << kk
                << setw(12) << x << setw(12) << y << endl;

        coord2hex( x+cd1, y-sd1, ki, kj, kk,
                   1.5*ct_local_PixelWidth_corner_2_corner_half);
        Map_Pixel(ki, kj, n);
        pixfile << setw(4) << n+1
                << setw(4) << ki << setw(4) << kj << setw(4) << kk
                << setw(12) << x << setw(12) << y << endl;

        // map then the pieces of small hexagons shared between big ones

        coord2hex( x  , y-d2 , ki, kj, kk,
                   1.5*ct_local_PixelWidth_corner_2_corner_half);
        Map_Multiple_Pixel(ki, kj, n);

        coord2hex( x+cd2, y+sd2, ki, kj, kk,
                   1.5*ct_local_PixelWidth_corner_2_corner_half);
        Map_Multiple_Pixel(ki, kj, n);

        coord2hex( x-cd2, y+sd2, ki, kj, kk,
                   1.5*ct_local_PixelWidth_corner_2_corner_half);
        Map_Multiple_Pixel(ki, kj, n);

      } else {

        // map also the three small hexagons inside the big one

        coord2hex( x  , y-d1 , ki, kj, kk,
                   1.5*ct_local_PixelWidth_corner_2_corner_half);
        Map_Pixel(ki, kj, n);
        pixfile << setw(4) << n+1
                << setw(4) << ki << setw(4) << kj << setw(4) << kk
                << setw(12) << x << setw(12) << y << endl;

        coord2hex( x+cd1, y+sd1, ki, kj, kk,
                   1.5*ct_local_PixelWidth_corner_2_corner_half);
        Map_Pixel(ki, kj, n);
        pixfile << setw(4) << n+1
                << setw(4) << ki << setw(4) << kj << setw(4) << kk
                << setw(12) << x << setw(12) << y << endl;

        coord2hex( x-cd1, y+sd1, ki, kj, kk,
                   1.5*ct_local_PixelWidth_corner_2_corner_half);
        Map_Pixel(ki, kj, n);
        pixfile << setw(4) << n+1
                << setw(4) << ki << setw(4) << kj << setw(4) << kk
                << setw(12) << x << setw(12) << y << endl;

        // map then the pieces of small hexagons shared between big ones

        coord2hex( x  , y+d2 , ki, kj, kk,
                   1.5*ct_local_PixelWidth_corner_2_corner_half);
        Map_Multiple_Pixel(ki, kj, n);

        coord2hex( x-cd2, y-sd2, ki, kj, kk,
                   1.5*ct_local_PixelWidth_corner_2_corner_half);
        Map_Multiple_Pixel(ki, kj, n);

        coord2hex( x+cd2, y-sd2, ki, kj, kk,
                   1.5*ct_local_PixelWidth_corner_2_corner_half);
        Map_Multiple_Pixel(ki, kj, n);

      }

      n++;

    }

  }

  // (iv) maping shared hexagons
  //------------------------------------------------------------

  log("create_pixels", "Maping shared hexagons . . .\n");

  pixfile << "#-- shared hexagons section -----------------------\n";

  for (i=0; i<PIX_ARRAY_SIDE; i++) {
    for (j=0; j<PIX_ARRAY_SIDE; j++) {
      n = pixels[i][j];
      if (n<0)
        continue;
      if (n>1000) {
        ki = i-PIX_ARRAY_HALF_SIDE;
        kj = j-PIX_ARRAY_HALF_SIDE;
        kk = -ki-kj;
        pixfile << setw(10) << n
                << setw(4) << ki << setw(4) << kj << setw(4) << kk
                << setw(2) << 0. << setw(2) << 0. << endl;
      } else {
        pixary[n][0] = px[n];
        pixary[n][1] = py[n];
      }
    }
  }

  pixfile << -1 << "\n# EOF\n" << flush;

  pixfile.close();

  log("create_pixels", "Done.\n");
}
//}


//## Direct (almost) identification of a pixel.


//!-----------------------------------------------------------
// @name pixel_id
//
// @desc returns the pixel number (ID) of pixel from any point inside
//
// @var x   Coord.X of point in the camera
// @var y   Coord.Y of point in the camera
// @return    pixel ID
//
// @date Fri Mar 31 16:32:48 MET DST 2000
//------------------------------------------------------------
// @function

//{
int
pixel_id (float x, float y)
{
  static int ki, kj, kk;
  static int n;
  static int j;
  static int p[3];

  static float a = ct_PixelWidth_corner_2_corner;
  static float b = ct_PixelWidth;
  static float c = 1. - 1./sqrt(3.);
  static float xx, yy;
  static float unit=1.5*ct_PixelWidth_corner_2_corner_half;

  coord2hex( x, y, ki, kj, kk, unit );

  n = -1;

  ki += PIX_ARRAY_HALF_SIDE;
  kj += PIX_ARRAY_HALF_SIDE;

  if ((ki<0) || (ki>=PIX_ARRAY_SIDE) ||
      (kj<0) || (kj>=PIX_ARRAY_SIDE))
    return n; // -1

  n = pixels[ki][kj];

  // we can have now 3 cases:
  // a) n==1
  //  the position (x,y) is outside any pixel
  //  the identification is direct
  // b) n in [0,max_num_pixel)
  //  the position (x,y) belongs to pixel n;
  //  the identification is direct
  // c) n > 1000
  //  the number n is in the form AAABBBCCC, where AAA, BBB
  //  and CCC are pixel IDs; we must test these three pixels
  //  the identification is more difficult
  //  this happens (under assumption of uniform light in the
  //  camera) about 10% of the times.

  // if n>1000  ==> this small hexagon belongs to more than
  //        one pixel (at least to one big pixel)
  if (n > 1000) {

    // identify the pixels where to look at
    p[2] = n % 1000;
    n /=1000;
    p[1] = n % 1000;
    n /=1000;
    p[0] = n;

    // look at each of those pixels
    n = -1;
    for (j=0; j<3; j++) {

      if (p[j] > 0) {
        xx = x - pixary[ p[j] ][0];
        yy = y - pixary[ p[j] ][1];

        // look whether position (xx,yy) is inside a big hexagon
        if (((-b <= xx) && (xx <= 0.)
             && ((-c * xx - a) <= yy) && (yy <= ( c * xx + a))) ||
            ((0. <  xx) && (xx <= b )
             && (( c * xx - a) <= yy) && (yy <= (-c * xx + a))) ) {
          n = p[j];
          break;
        }

      }

    }

  }

  return n;  // if n==-1  ==> outside any pixel
}
//}


//## Utility functions.


//!-----------------------------------------------------------
// @name pixels_are_neig
//
// @desc check whether two pixels are neighbours
//
// @var pix1    Number of the first pixel
// @var pix2    Number of the second pixel
// @return    TRUE: both pixels are neighbours; FALSE: oth.
//
// @date Wed Sep  9 17:58:37 MET DST 1998
//------------------------------------------------------------
// @function

//{
static bool
pixels_are_neig(int pix1, int pix2)
{
  if ( sqrt(sqr( pixary[pix1][0] - pixary[pix2][0] ) +
            sqr( pixary[pix1][1] - pixary[pix2][1] ) )
       > ct_PixelWidth_corner_2_corner )
    return ( false );
  else
    return ( true );
}
//}


//!-----------------------------------------------------------
// @name pixel_bit_mask
//
// @desc calculates the bit mask for a given pixel
//
// @var i     Number of the pixel
// @var q0    Threshold in num.ph.e-s per pixel
// @var d     Pointer to the array of discriminator histograms
// @var b     Bin in time where we look for coincidences
//
// @return    Bit mask in the form of an integer
//
// @date Wed Jan 19 14:06:52 MET 2000
//------------------------------------------------------------
// @function

//{
int
pixel_bit_mask(int i, float q0, Histogram<float> **d, int b)
{
  static int triggerBits;
  static int bit;

  register int j;

#define DISCRIMINATOR(x,y) (d[x])->get_content(y)

  triggerBits = (DISCRIMINATOR(i,b) > 0.5) ? 1 : 0;

  for ( j=0 ; j<npixneig[i] && pixneig[i][j]>-1; ++j ) {

    if ( DISCRIMINATOR(pixneig[i][j],b) > 0.5 ) {

      if ( pixary[pixneig[i][j]][0] > pixary[i][0] ) {

        if ( nint(pixary[pixneig[i][j]][1]*10.0) >
             nint(pixary[i][1]*10.0) )
          bit = 2;
        else if ( nint(pixary[pixneig[i][j]][1]*10.0) <
                  nint(pixary[i][1]*10.0) )
          bit = 6;
        else
          bit = 1;

      } else {

        if ( nint(pixary[pixneig[i][j]][1]*10.0) >
             nint(pixary[i][1]*10.0) )
          bit = 3;
        else if ( nint(pixary[pixneig[i][j]][1]*10.0) <
                  nint(pixary[i][1]*10.0) )
          bit = 5;
        else
          bit = 4;

      }

      triggerBits |= (1<<bit);

    }

  }

  return triggerBits;
}
//}


//!-----------------------------------------------------------
// @name coord2hex
//
// @desc returns the coordinates (i,j,k) of pixel for point (cx,cy)
//
// @var cx    Coord.X of point in the camera
// @var cy    Coord.Y of point in the camera
// @var ki    Reference to the x' coordinate i
// @var kj    Reference to the y' coordinate j
// @var kk    Reference to the z' coordinate k
//
// @date Fri Mar 31 16:18:33 MET DST 2000
//------------------------------------------------------------
// @function

//{
static void
coord2hex (float cx, float cy, int &ki, int &kj, int &kk,
           float unit=1.5*ct_PixelWidth_corner_2_corner_half)
{
  float dx, dy, dz;
  float rx, ry, rz;
  float ax, ay, az;
  int s;

  xy2ijk (cx, cy, dx, dy, dz, unit);

  rx = frint(dx);
  ry = frint(dy);
  rz = frint(dz);

  ki = int(rx);
  kj = int(ry);
  kk = int(rz);

  s = ki + kj + kk;
  if (s) {
    ax = fabs(rx-dx);
    ay = fabs(ry-dy);
    az = fabs(rz-dz);

    if ((ax >= ay) && (ax >= az)) { ki -= s; }
    else if ((ay >= ax) && (ay >= az)) { kj -= s; }
    else { kk -= s; }
  }
}
//}


//!-----------------------------------------------------------
// @name hex2coord
//
// @desc returns the coordinates (x,y) of the center of a pixel (i,j,k)
//
// @var ki    Coord.X' of pixel in the camera
// @var kj    Coord.Y' of pixel in the camera
// @var kk    Coord.Z' of pixel in the camera
// @var cx    Reference to the x coordinate
// @var cy    Reference to the y coordinate
//
// @date Fri Mar 31 16:18:33 MET DST 2000
//------------------------------------------------------------
// @function

//{
static void
hex2coord (int ki, int kj, int kk, float &x, float &y,
           float unit = ct_PixelWidth_corner_2_corner_half)
{
  x = (ki*COS30 - kj*COS30) * unit;
  y = ((ki+kj)*SIN30 - kk) * unit;
}
//}


//!-----------------------------------------------------------
// @name ijk2xy
//
// @desc returns the coordinates (x,y) corresponding to any (i,j,k)
//
// @var ki    Coord.X' of pixel in the camera
// @var kj    Coord.Y' of pixel in the camera
// @var kk    Coord.Z' of pixel in the camera
// @var cx    Reference to the x coordinate
// @var cy    Reference to the y coordinate
//
// @date Fri Mar 31 16:18:33 MET DST 2000
//------------------------------------------------------------
// @function

//{
static void
ijk2xy (float ki, float kj, float kk, float &x, float &y,
        float unit = ct_PixelWidth_corner_2_corner_half)
{
  x = (ki*COS30 - kj*COS30) * unit;
  y = ((ki+kj)*SIN30 - kk) * unit;
}
//}


//!-----------------------------------------------------------
// @name xy2ijk
//
// @desc returns the coordinates (x,y) corresponding to any (x,y)
//
// @var cx    Coord.X of point in the camera
// @var cy    Coord.Y of point in the camera
// @var di    Reference to the x' coordinate i
// @var dj    Reference to the y' coordinate j
// @var dk    Reference to the z' coordinate k
//
// @date Fri Mar 31 16:18:33 MET DST 2000
//------------------------------------------------------------
// @function

//{
static void
xy2ijk (float cx, float cy, float &di, float &dj, float &dk,
        float unit = 1.5*ct_PixelWidth_corner_2_corner_half)
{
  float x, y;

  x = (  cx*COS30 + cy*SIN30);
  y = (- cx*SIN30 + cy*COS30);

  di = x / unit;
  dj = (- x*SIN30 + y*COS30) / unit;
  dk = (- x*SIN30 - y*COS30) / unit;
}
//}


//!-----------------------------------------------------------
// @name create_sps
//
// @desc creates Single Photoelectron Spectrum curve to use
//
// @var x  Reference to vector of X of the curve
// @var y  Reference to vector of Y of the curve
//
// @date Fri Mar 31 16:18:33 MET DST 2000
//------------------------------------------------------------
// @function

//{
void
create_sps (float* & x, float* & y, float mymean)
{
  int i;
  float mx;
  float ssps = 0.;  // sum of original Single Phe Spectrum data
  float sspsx = 0.; // sum of X times original Single Phe Spectrum data

  log("create_sps", "Creating Single Photoelectron Spectrum. . .\n");

  x = new float [ nSinglePheSpectrum ];
  y = new float [ nSinglePheSpectrum ];

  // calculate mean in X value
  ssps = sspsx = 0.;
  for (i=0; i<nSinglePheSpectrum; i++) {
    x[i] = (i+0.5);
    ssps  += SinglePheSpectrum[i];
    sspsx += SinglePheSpectrum[i] * x[i];
  }

  mx = sspsx / ssps;

  // correct X values to require user provided mean sps_Mean
  sspsx = 0.;
  for (i=0; i<nSinglePheSpectrum; i++) {
    x[i] = x[i] * mymean / mx;
    sspsx += SinglePheSpectrum[i] * x[i];
  }

  mx = sspsx / ssps;

  if (fabs(1.0-mymean/mx)>1.0e-4)
    error("create_sps", "Required sps_Mean (%f) != calculated one (%f).\n",
          mymean, mx);

  // normalize histogram to have probabilities (integral == 1)
  for (i=0; i<nSinglePheSpectrum; i++) {
    y[i] = SinglePheSpectrum[i] / ssps;
  }

  // dump everything to a file
  log("create_sps", "Creating the file \"%s\" . . .\n", SINGLE_PHE_SPEC_FILE);

  // open new file
  ofstream spsfile;
  spsfile.open( SINGLE_PHE_SPEC_FILE );

  // write header
  spsfile << "#--------------------------------------------------\n";
  spsfile << "# " << SINGLE_PHE_SPEC_FILE
          << " -- single photoelectron spectrum file\n";
  spsfile << "#\n";
  spsfile << "# Kopyleft (K) 2000 J C Gonzalez\n";
  spsfile << "# Automatically generated by camera program\n";
  spsfile << "#--------------------------------------------------\n#\n";

  // dump data
  for (i=0; i<nSinglePheSpectrum; i++)
    spsfile << setw(12) << x[i] << setw(12) << y[i] << endl;

  // close file
  spsfile.close();

  log("create_sps", "Done.\n");
}
//}


//!-----------------------------------------------------------
// @name add_phe_signal
//
// @desc adds single ph.e. signal to pulse histograms
//
// @var t      time of this ph.e. (center of the signal)
// @var h      pointer to histogram
// @var htot   pointer to histogram of the whole shower
// @var sX     vector of X in single ph.e. spectrum
// @var sY     vector of Y in single ph.e. spectrum
//
// @date Fri Mar 31 16:18:33 MET DST 2000
//------------------------------------------------------------
// @function

//{
static void
add_phe_signal (float t, Histogram<float> *h, Histogram<float> *htot,
                float *sX, float *sY, float sigma, float amplitude_factor)
{
  static bool  first = true;
  static const int number_of_sigmas = 3;
  static float *x;
  static float *y;
  static int   nbins;
  static float *xtot;
  static float *ytot;
  static int   nbinstot;
  static float maxY;
  static float aX;
  static float bX;
  static float binX;

  static float amplitude;  // amplitude of the signal

  register int i;

  // if this is the first time, create arrays
  if ( first ) {

    // create vectors (x,y) for individual pulses
    float binsize = h->get_binsize();
    nbins = int(ceil(sigma * number_of_sigmas / binsize));
    x = new float [ 2 * nbins + 1 ];
    y = new float [ 2 * nbins + 1 ];

    // create vectors (xtot,ytot) for pulses for the whole shower
    float binsizetot = htot->get_binsize();
    nbinstot = int(ceil(sigma * number_of_sigmas / binsizetot));
    xtot = new float [ 2 * nbinstot + 1 ];
    ytot = new float [ 2 * nbinstot + 1 ];

    // fill x and xtot vectors
    for (i=-nbins; i<=nbins; i++)
      x[i + nbins] = i * binsize;

    for (i=-nbinstot; i<=nbinstot; i++)
      xtot[i + nbins] = i * binsizetot;

    // calculate y and ytot vectors (gaussians of sigma "sigma")       
    for (i=0; i<2*nbins+1; i++)
      y[i] = exp(-sqr(x[i])/(2 * sqr(sigma)))/(sqrt(2. * M_PI) * sigma);

    for (i=0; i<2*nbinstot+1; i++)
      ytot[i] = exp(-sqr(xtot[i])/(2 * sqr(sigma)))/(sqrt(2. * M_PI) * sigma);

    // looks for maximum (top) value un S.P.S. (bottom is zero)
    maxY = 0.;
    for (i=0; i<nSinglePheSpectrum; i++)
      if (sY[i] > maxY) maxY = sY[i];

    // calculate bin width for S.P.S.        
    binX = ((sX[nSinglePheSpectrum - 1] - sX[0]) /
            float(nSinglePheSpectrum - 1));

    // calculate left and right edges for Von Neumann's method
    aX = sX[0] - binX * 0.5;
    bX = sX[nSinglePheSpectrum-1] + binX * 0.5;

    first = false;
  }

#ifdef __DEBUG__
  cerr << aX << ' ' << bX << ' ' << binX << endl;
#endif // __DEBUG__

  // get amplitude
  amplitude  = random_von_neumann( sX, sY, nSinglePheSpectrum, maxY, aX, bX );
  amplitude *= amplitude_factor;

#ifdef __DEBUG__
  cerr << "amplitude of phe signal = " << amplitude << endl;
#endif // __DEBUG__

  for (i=0; i<=2*nbins+1; i++)
    h->fill( t + x[i], y[i] * amplitude );

  for (i=0; i<=2*nbinstot+1; i++)
    htot->fill( t + xtot[i], ytot[i] * amplitude );
}
//}


//!-----------------------------------------------------------
// @name random_von_neumann
//
// @desc gets a random value out of a frequency histogram
//
// @var x      x coordinates of the histogram (center of bin)
// @var y      y coordinates of the histogram (frequency)
// @var n      number of bins
// @var maxy   precalculated maximum of the y values
// @var a      lower edge for x values
// @var b      upper edge for x values
//
// @date Fri Mar 31 16:18:33 MET DST 2000
//------------------------------------------------------------
// @function

//{
static float
random_von_neumann( float *x, float *y, int n,
                    float maxy, float a, float b )
{
  static float rx;
  static float ry;
  static int   ri;
  static float rbin;

#ifdef __DEBUG__
  cerr << "random_von_neumann: "
       << n << ' ' << maxy << ' ' << a << ' ' << b << endl;
#endif // __DEBUG__

  rbin = (b-a)/n;

  // simplified algorithm (check!!)
  do {
    // generate random values
    rx = RandomNumber * (b-a) + a;   // random value for x
    ry = RandomNumber * maxy;      // random value for y
    ri = int(rx/rbin);
#ifdef __DEBUG__
    cerr << "loop: " << rx << ' ' << ry << ' ' << ri << endl;
#endif // __DEBUG__
  } while (ry > y[ri]);

#ifdef __DEBUG__
  cerr << ri << ' ' << rx << ' ' << ry << endl;
#endif // __DEBUG__

  return rx;
}
//}


//!-----------------------------------------------------------
// @name read_bin_data
//
// @desc read binary data from stream
//
// @var pdata  pointer to data
// @var bytes  number of bytes to read
// @var source   flag to get data from STDIN of from file
// @var file   input file stream
//
// @date Fri Mar 31 16:18:33 MET DST 2000
//------------------------------------------------------------
// @function

//{
static void
read_bin_data( char *pdata, int bytes, int source, ifstream &file )
{
  if ( source )
    cin.read( pdata, bytes );
  else
    file.read( pdata, bytes );
}
//}


//=------------------------------------------------------------
//## Log of this file.

//{
//
// $Log$
// Revision 1.38  2000/06/07 20:52:45  gonzalez
//
// camera
//
// Behaviour: Complex, pixelization and histograming in time
//
// Status: READY
//
// Revision 1.39  2000/06/06  15:25:22  gonzalez
// *** empty log message ***
//
// Revision 1.38  2000/05/29  16:01:26  gonzalez
// *** empty log message ***
//
// Revision 1.37  2000/03/22  14:15:56  gonzalez
// *** empty log message ***
//
// Revision 1.36  2000/02/20  11:38:38  gonzalez
// *** empty log message ***
//
// Revision 1.35  2000/02/15  10:29:51  gonzalez
// *** empty log message ***
//
// Revision 1.34  2000/02/14  07:58:45  gonzalez
// *** empty log message ***
//
// Revision 1.33  2000/02/12  14:25:54  gonzalez
// *** empty log message ***
//
// Revision 1.32  2000/02/11  19:36:07  gonzalez
// *** empty log message ***
//
// Revision 1.31  2000/02/11  06:47:48  gonzalez
// Real camera for MAGIC: test 1
//
// Revision 1.30  2000/02/10  08:57:42  gonzalez
// *** empty log message ***
//
// Revision 1.29  2000/02/01  16:08:10  gonzalez
// Implementation of new pixelization routine.
// Tests are still on the way.
//
// Revision 1.28  2000/01/30  08:13:20  gonzalez
// *** empty log message ***
//
// Revision 1.27  2000/01/28  06:40:21  gonzalez
// Time in trigger + trigger patterns working ...
//
// Revision 1.26  2000/01/27  10:48:50  gonzalez
// Trigger patterns + timing seem to work
//
// Revision 1.25  1999/12/13  14:57:28  gonzalez
// pre-navidades 2000
//
// Revision 1.24  1999/12/03  17:18:08  gonzalez
// *** empty log message ***
//
// Revision 1.23  1999/11/25  16:41:42  gonzalez
// *** empty log message ***
//
// Revision 1.22  1999/11/25  07:48:15  gonzalez
// *** empty log message ***
//
// Revision 1.21  1999/11/24  18:13:55  gonzalez
// *** empty log message ***
//
// Revision 1.20  1999/11/24  15:59:16  gonzalez
// *** empty log message ***
//
// Revision 1.19  1999/11/24  15:36:19  gonzalez
// *** empty log message ***
//
// Revision 1.18  1999/11/22  21:02:11  gonzalez
// *** empty log message ***
//
// Revision 1.17  1999/11/19  20:52:24  gonzalez
// *** empty log message ***
//
// Revision 1.16  1999/11/17  13:32:04  gonzalez
// Nov.1999
//
// Revision 1.15  1999/10/08  08:00:01  gonzalez
// Bug in ISLANDS algorithm fixed
//
// Revision 1.14  1999/10/05  11:42:34  gonzalez
// Sep. 1999
//
// Revision 1.13  1999/03/15  14:59:05  gonzalez
// camera-1_1
//
// Revision 1.12  1999/03/02  09:56:10  gonzalez
// *** empty log message ***
//
//
//}

//=EOF
